<!DOCTYPE html>
<!-- saved from url=(0047)https://rust-embedded.github.io/book/print.html -->
<html lang="en" class="js sidebar-visible light"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <!-- Book generated using mdBook -->
        
        <title>The Embedded Rust Book</title>
        
        <meta name="robots" content="noindex">
        

        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="rgba(0, 0, 0, 0)">

        <link rel="shortcut icon" href="https://rust-embedded.github.io/book/favicon.png">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/variables.css">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/general.css">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/chrome.css">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="./The Embedded Rust Book_files/font-awesome.css">
        <link href="./The Embedded Rust Book_files/css" rel="stylesheet" type="text/css">
        <link href="./The Embedded Rust Book_files/css(1)" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="./The Embedded Rust Book_files/highlight.css">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/tomorrow-night.css" disabled="">
        <link rel="stylesheet" href="./The Embedded Rust Book_files/ayu-highlight.css" disabled="">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents" aria-hidden="false">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/index.html" tabindex="0"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/hardware.html" tabindex="0"><strong aria-hidden="true">1.1.</strong> Hardware</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/no-std.html" tabindex="0"><strong aria-hidden="true">1.2.</strong> no_std</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/tooling.html" tabindex="0"><strong aria-hidden="true">1.3.</strong> Tooling</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/install.html" tabindex="0"><strong aria-hidden="true">1.4.</strong> Installation</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/install/linux.html" tabindex="0"><strong aria-hidden="true">1.4.1.</strong> Linux</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/install/macos.html" tabindex="0"><strong aria-hidden="true">1.4.2.</strong> MacOS</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/install/windows.html" tabindex="0"><strong aria-hidden="true">1.4.3.</strong> Windows</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/intro/install/verify.html" tabindex="0"><strong aria-hidden="true">1.4.4.</strong> Verify Installation</a></li></ol></li></ol></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/index.html" tabindex="0"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/start/qemu.html" tabindex="0"><strong aria-hidden="true">2.1.</strong> QEMU</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/hardware.html" tabindex="0"><strong aria-hidden="true">2.2.</strong> Hardware</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/registers.html" tabindex="0"><strong aria-hidden="true">2.3.</strong> Memory-mapped Registers</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/semihosting.html" tabindex="0"><strong aria-hidden="true">2.4.</strong> Semihosting</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/panicking.html" tabindex="0"><strong aria-hidden="true">2.5.</strong> Panicking</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/exceptions.html" tabindex="0"><strong aria-hidden="true">2.6.</strong> Exceptions</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/interrupts.html" tabindex="0"><strong aria-hidden="true">2.7.</strong> Interrupts</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/start/io.html" tabindex="0"><strong aria-hidden="true">2.8.</strong> IO</a></li></ol></li><li class="expanded "><a href="https://rust-embedded.github.io/book/peripherals/index.html" tabindex="0"><strong aria-hidden="true">3.</strong> Peripherals</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/peripherals/a-first-attempt.html" tabindex="0"><strong aria-hidden="true">3.1.</strong> A first attempt in Rust</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/peripherals/borrowck.html" tabindex="0"><strong aria-hidden="true">3.2.</strong> The Borrow Checker</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/peripherals/singletons.html" tabindex="0"><strong aria-hidden="true">3.3.</strong> Singletons</a></li></ol></li><li class="expanded "><a href="https://rust-embedded.github.io/book/static-guarantees/index.html" tabindex="0"><strong aria-hidden="true">4.</strong> Static Guarantees</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/static-guarantees/typestate-programming.html" tabindex="0"><strong aria-hidden="true">4.1.</strong> Typestate Programming</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/static-guarantees/state-machines.html" tabindex="0"><strong aria-hidden="true">4.2.</strong> Peripherals as State Machines</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/static-guarantees/design-contracts.html" tabindex="0"><strong aria-hidden="true">4.3.</strong> Design Contracts</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/static-guarantees/zero-cost-abstractions.html" tabindex="0"><strong aria-hidden="true">4.4.</strong> Zero Cost Abstractions</a></li></ol></li><li class="expanded "><a href="https://rust-embedded.github.io/book/portability/index.html" tabindex="0"><strong aria-hidden="true">5.</strong> Portability</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/concurrency/index.html" tabindex="0"><strong aria-hidden="true">6.</strong> Concurrency</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/collections/index.html" tabindex="0"><strong aria-hidden="true">7.</strong> Collections</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/c-tips/index.html" tabindex="0"><strong aria-hidden="true">8.</strong> Tips for embedded C developers</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/interoperability/index.html" tabindex="0"><strong aria-hidden="true">9.</strong> Interoperability</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/interoperability/c-with-rust.html" tabindex="0"><strong aria-hidden="true">9.1.</strong> A little C with your Rust</a></li><li class="expanded "><a href="https://rust-embedded.github.io/book/interoperability/rust-with-c.html" tabindex="0"><strong aria-hidden="true">9.2.</strong> A little Rust with your C</a></li></ol></li><li class="expanded "><a href="https://rust-embedded.github.io/book/unsorted/index.html" tabindex="0"><strong aria-hidden="true">10.</strong> Unsorted topics</a></li><li><ol class="section"><li class="expanded "><a href="https://rust-embedded.github.io/book/unsorted/speed-vs-size.html" tabindex="0"><strong aria-hidden="true">10.1.</strong> Optimizations: The speed size tradeoff</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar folded bordered">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar" aria-expanded="true">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">The Embedded Rust Book</h1>

                        <div class="right-buttons">
                            <a href="https://rust-embedded.github.io/book/print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="https://rust-embedded.github.io/book/print.html#introduction" id="introduction">Introduction</a></h1>
<p>Welcome to The Embedded Rust Book: An introductory book about using the Rust
Programming Language on "Bare Metal" embedded systems, such as Microcontrollers.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#who-embedded-rust-is-for" id="who-embedded-rust-is-for">Who Embedded Rust is For</a></h2>
<p>Embedded Rust is for everyone who wants to do embedded programming while taking advantage of the higher-level concepts and safety guarantees the Rust language provides.
(See also <a href="https://doc.rust-lang.org/book/ch00-00-introduction.html">Who Rust Is For</a>)</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#scope" id="scope">Scope</a></h2>
<p>The goals of this book are:</p>
<ul>
<li>
<p>Get developers up to speed with embedded Rust development. i.e. How to set
up a development environment.</p>
</li>
<li>
<p>Share <em>current</em> best practices about using Rust for embedded development. i.e.
How to best use Rust language features to write more correct embedded
software.</p>
</li>
<li>
<p>Serve as a cookbook in some cases. e.g. How do I do mix C and Rust in a single
project?</p>
</li>
</ul>
<p>This book tries to be as general as possible but to make things easier for both
the readers and the writers it uses the ARM Cortex-M architecture in all its
examples. However, the book doesn't assume that the reader is familiar with this
particular architecture and explains details particular to this architecture
where required.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#who-this-book-is-for" id="who-this-book-is-for">Who This Book is For</a></h2>
<p>This book caters towards people with either some embedded background or some Rust background, however we believe
everybody curious about embedded Rust programming can get something out of this book. For those without any prior knowledge
we suggest you read the "Assumptions and Prerequisites" section and catch up on missing knowledge to get more out of the book
and improve your reading experience. You can check out the "Other Resources" section to find resources on topics
you might want to catch up on.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#assumptions-and-prerequisites" id="assumptions-and-prerequisites">Assumptions and Prerequisites</a></h3>
<ul>
<li>You are comfortable using the Rust Programming Language, and have written,
run, and debugged Rust applications on a desktop environment. You should also
be familiar with the idioms of the <a href="https://doc.rust-lang.org/edition-guide/">2018 edition</a> as this book targets
Rust 2018.</li>
</ul>
<ul>
<li>You are comfortable developing and debugging embedded systems in another
language such as C, C++, or Ada, and are familiar with concepts such as:
<ul>
<li>Cross Compilation</li>
<li>Memory Mapped Peripherals</li>
<li>Interrupts</li>
<li>Common interfaces such as I2C, SPI, Serial, etc.</li>
</ul>
</li>
</ul>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#other-resources" id="other-resources">Other Resources</a></h3>
<p>If you are unfamiliar with anything mentioned above or if you want more information about a specific topic mentioned in this book you might find some of these resources helpful.</p>
<table><thead><tr><th>Topic</th><th>Resource</th><th>Description</th></tr></thead><tbody>
<tr><td>Rust</td><td><a href="https://doc.rust-lang.org/book/">Rust Book</a></td><td>If you are not yet comfortable with Rust, we highly suggest reading this book.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/">Embedded Rust Bookshelf</a></td><td>Here you can find several other resources provided by Rust's Embedded Working Group.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/embedonomicon/">Embedonomicon</a></td><td>The nitty gritty details when doing embedded programming in Rust.</td></tr>
<tr><td>Rust, Embedded</td><td><a href="https://docs.rust-embedded.org/faq.html">embedded FAQ</a></td><td>Frequently asked questions about Rust in an embedded context.</td></tr>
<tr><td>Interrupts</td><td><a href="https://en.wikipedia.org/wiki/Interrupt">Interrupt</a></td><td>-</td></tr>
<tr><td>Memory-mapped IO/Peripherals</td><td><a href="https://en.wikipedia.org/wiki/Memory-mapped_I/O">Memory-mapped I/O</a></td><td>-</td></tr>
<tr><td>SPI, UART, RS232, USB, I2C, TTL</td><td><a href="https://electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-ttl-etc-what-are-all-of-these-and-how-do-th">Stack Exchange about SPI, UART, and other interfaces</a></td><td>-</td></tr>
</tbody></table>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#how-to-use-this-book" id="how-to-use-this-book">How to Use This Book</a></h2>
<p>This book generally assumes that you’re reading it front-to-back. Later
chapters build on concepts in earlier chapters, and earlier chapters may
not dig into details on a topic, revisiting the topic in a later chapter.</p>
<p>This book will be using the <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> development board from
STMicroelectronics for the majority of the examples contained within. This board
is based on the ARM Cortex-M architecture, and while basic functionality is
the same across most CPUs based on this architecture, peripherals and other
implementation details of Microcontrollers are different between different
vendors, and often even different between Microcontroller families from the same
vendor.</p>
<p>For this reason, we suggest purchasing the <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a> development board
for the purpose of following the examples in this book.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#contributing-to-this-book" id="contributing-to-this-book">Contributing to This Book</a></h2>
<p>The work on this book is coordinated in <a href="https://github.com/rust-embedded/book">this repository</a> and is mainly
developed by the <a href="https://github.com/rust-embedded/wg#the-resources-team">resources team</a>.</p>
<p>If you have trouble following the instructions in this book or find that some
section of the book is not clear enough or hard to follow then that's a bug and
it should be reported in <a href="https://github.com/rust-embedded/book/issues/">the issue tracker</a> of this book.</p>
<p>Pull requests fixing typos and adding new content are very welcome!</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#meet-your-hardware" id="meet-your-hardware">Meet Your Hardware</a></h1>
<p>Let's get familiar with the hardware we'll be working with.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#stm32f3discovery-the-f3" id="stm32f3discovery-the-f3">STM32F3DISCOVERY (the "F3")</a></h2>
<p align="center">
<img title="F3" src="./The Embedded Rust Book_files/f3.jpg">
</p>
<p>What does this board contain?</p>
<ul>
<li>
<p>A <a href="https://www.st.com/en/microcontrollers/stm32f303vc.html">STM32F303VCT6</a> microcontroller. This microcontroller has</p>
<ul>
<li>
<p>A single-core ARM Cortex-M4F processor with hardware support for single-precision floating point
operations and a maximum clock frequency of 72 MHz.</p>
</li>
<li>
<p>256 KiB of "Flash" memory. (1 KiB = 10<strong>24</strong> bytes)</p>
</li>
<li>
<p>48 KiB of RAM.</p>
</li>
<li>
<p>A variety of integrated peripherals such as timers, I2C, SPI and USART.</p>
</li>
<li>
<p>General purpose Input Output (GPIO) and other types of pins accessible through the two rows of headers along side the board.</p>
</li>
<li>
<p>A USB interface accessible through the USB port labeled "USB USER".</p>
</li>
</ul>
</li>
<li>
<p>An <a href="https://en.wikipedia.org/wiki/Accelerometer">accelerometer</a> as part of the <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a> chip.</p>
</li>
<li>
<p>A <a href="https://en.wikipedia.org/wiki/Magnetometer">magnetometer</a> as part of the <a href="https://www.st.com/en/mems-and-sensors/lsm303dlhc.html">LSM303DLHC</a> chip.</p>
</li>
<li>
<p>A <a href="https://en.wikipedia.org/wiki/Gyroscope">gyroscope</a> as part of the <a href="https://www.pololu.com/file/0J563/L3GD20.pdf">L3GD20</a> chip.</p>
</li>
<li>
<p>8 user LEDs arranged in the shape of a compass.</p>
</li>
<li>
<p>A second microcontroller: a <a href="https://www.st.com/en/microcontrollers/stm32f103cb.html">STM32F103</a>. This microcontroller is actually part of an on-board programmer / debugger and is connected to the USB port named "USB ST-LINK".</p>
</li>
</ul>
<p>For a more detailed list of features and further specifications of the board take a look at the <a href="https://www.st.com/en/evaluation-tools/stm32f3discovery.html">STMicroelectronics</a> website.</p>
<p>A word of caution: be careful if you want to apply external signals to the board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 volts. For further information consult the <a href="https://www.st.com/resource/en/datasheet/stm32f303vc.pdf">6.2 Absolute maximum ratings section in the manual</a></p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#a-no_std-rust-environment" id="a-no_std-rust-environment">A <code class="hljs">no_std</code> Rust Environment</a></h1>
<p>The term Embedded Programming is used for a wide range of different classes of programming.
Ranging from programming 8-Bit MCUs (like the <a href="https://www.st.com/resource/en/datasheet/st72325j6.pdf">ST72325xx</a>)
with just a few KB of RAM and ROM, up to systems like the Raspberry Pi
(<a href="https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications">Model B 3+</a>) which has a 32/64-bit
4-core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations will apply when writing code
depending on what kind of target and use case you have.</p>
<p>There are two general Embedded Programming classifications:</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#hosted-environments" id="hosted-environments">Hosted Environments</a></h2>
<p>These kinds of environments are close to a normal PC environment.
What this means is that you are provided with a System Interface <a href="https://en.wikipedia.org/wiki/POSIX">E.G. POSIX</a>
that provides you with primitives to interact with various systems, such as file systems, networking, memory management, threads, etc.
Standard libraries in turn usually depend on these primitives to implement their functionality.
You may also have some sort of sysroot and restrictions on RAM/ROM-usage, and perhaps some
special HW or I/Os. Overall it feels like coding on a special-purpose PC environment.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#bare-metal-environments" id="bare-metal-environments">Bare Metal Environments</a></h2>
<p>In a bare metal environment no code has been loaded before your program.
Without the software provided by an OS we can not load the standard library.
Instead the program, along with the crates it uses, can only use the hardware (bare metal) to run.
To prevent rust from loading the standard library use <code class="hljs">no_std</code>.
The platform-agnostic parts of the standard library are available through <a href="https://doc.rust-lang.org/core/">libcore</a>.
libcore also excludes things which are not always desirable in an embedded environment.
One of these things is a memory allocator for dynamic memory allocation.
If you require this or any other functionalities there are often crates which provide these.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#the-libstd-runtime" id="the-libstd-runtime">The libstd Runtime</a></h3>
<p>As mentioned before using <a href="https://doc.rust-lang.org/std/">libstd</a> requires some sort of system integration, but this is not only because
<a href="https://doc.rust-lang.org/std/">libstd</a> is just providing a common way of accessing OS abstractions, it also provides a runtime.
This runtime, among other things, takes care of setting up stack overflow protection, processing command line arguments,
and spawning the main thread before a program's main function is invoked. This runtime also won't be available in a <code class="hljs">no_std</code> environment.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#summary" id="summary">Summary</a></h2>
<p><code class="hljs">#![no_std]</code> is a crate-level attribute that indicates that the crate will link to the core-crate instead of the std-crate.
The <a href="https://doc.rust-lang.org/core/">libcore</a> crate in turn is a platform-agnostic subset of the std crate
which makes no assumptions about the system the program will run on.
As such, it provides APIs for language primitives like floats, strings and slices, as well as APIs that expose processor features
like atomic operations and SIMD instructions. However it lacks APIs for anything that involves platform integration.
Because of these properties no_std and <a href="https://doc.rust-lang.org/core/">libcore</a> code can be used for any kind of
bootstrapping (stage 0) code like bootloaders, firmware or kernels.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#overview" id="overview">Overview</a></h3>
<table><thead><tr><th>feature</th><th>no_std</th><th>std</th></tr></thead><tbody>
<tr><td>heap (dynamic memory)</td><td>*</td><td>✓</td></tr>
<tr><td>collections (Vec, HashMap, etc)</td><td>**</td><td>✓</td></tr>
<tr><td>stack overflow protection</td><td>✘</td><td>✓</td></tr>
<tr><td>runs init code before main</td><td>✘</td><td>✓</td></tr>
<tr><td>libstd available</td><td>✘</td><td>✓</td></tr>
<tr><td>libcore available</td><td>✓</td><td>✓</td></tr>
<tr><td>writing firmware, kernel, or bootloader code</td><td>✓</td><td>✘</td></tr>
</tbody></table>
<p>* Only if you use the <code class="hljs">alloc</code> crate and use a suitable allocator like <a href="https://github.com/rust-embedded/alloc-cortex-m">alloc-cortex-m</a>.</p>
<p>** Only if you use the <code class="hljs">collections</code> crate and configure a global default allocator.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#see-also" id="see-also">See Also</a></h2>
<ul>
<li><a href="https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md">RFC-1184</a></li>
</ul>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#tooling" id="tooling">Tooling</a></h1>
<p>Dealing with microcontrollers involves using several different tools as we'll be
dealing with an architecture different than your laptop's and we'll have to run
and debug programs on a <em>remote</em> device.</p>
<p>We'll use all the tools listed below. Any recent version should work when a
minimum version is not specified, but we have listed the versions we have
tested.</p>
<ul>
<li>Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation
support.</li>
<li><a href="https://github.com/rust-embedded/cargo-binutils"><code class="hljs">cargo-binutils</code></a> ~0.1.4</li>
<li><a href="https://www.qemu.org/"><code class="hljs">qemu-system-arm</code></a>. Tested versions: 3.0.0</li>
<li>OpenOCD &gt;=0.8. Tested versions: v0.9.0 and v0.10.0</li>
<li>GDB with ARM support. Version 7.12 or newer highly recommended. Tested
versions: 7.10, 7.11, 7.12 and 8.1</li>
<li><a href="https://github.com/ashleygwilliams/cargo-generate"><code class="hljs">cargo-generate</code></a> or <code class="hljs">git</code>.
These tools are optional but will make it easier to follow along with the book.</li>
</ul>
<p>The text below explains why we are using these tools. Installation instructions
can be found on the next page.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#cargo-generate-or-git" id="cargo-generate-or-git"><code class="hljs">cargo-generate</code> OR <code class="hljs">git</code></a></h2>
<p>Bare metal programs are non-standard (<code class="hljs">no_std</code>) Rust programs that require some
adjustments to the linking process in order to get the memory layout of the program
right. This requires some additional files (like linker scripts) and 
settings (like linker flags). We have packaged those for you in a template
such that you only need to fill in the missing information (such as the project name and the
characteristics of your target hardware).</p>
<p>Our template is compatible with <code class="hljs">cargo-generate</code>: a Cargo subcommand for
creating new Cargo projects from templates. You can also download the
template using <code class="hljs">git</code>, <code class="hljs">curl</code>, <code class="hljs">wget</code>, or your web browser.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#cargo-binutils" id="cargo-binutils"><code class="hljs">cargo-binutils</code></a></h2>
<p><code class="hljs">cargo-binutils</code> is a collection of Cargo subcommands that make it easy to use
the LLVM tools that are shipped with the Rust toolchain. These tools include the
LLVM versions of <code class="hljs">objdump</code>, <code class="hljs">nm</code> and <code class="hljs">size</code> and are used for inspecting
binaries.</p>
<p>The advantage of using these tools over GNU binutils is that (a) installing the
LLVM tools is the same one-command installation (<code class="hljs">rustup component add llvm-tools-preview</code>) regardless of your OS and (b) tools like <code class="hljs">objdump</code> support
all the architectures that <code class="hljs">rustc</code> supports -- from ARM to x86_64 -- because
they both share the same LLVM backend.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#qemu-system-arm" id="qemu-system-arm"><code class="hljs">qemu-system-arm</code></a></h2>
<p>QEMU is an emulator. In this case we use the variant that can fully emulate ARM
systems. We use QEMU to run embedded programs on the host. Thanks to this you
can follow some parts of this book even if you don't have any hardware with you!</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#gdb" id="gdb">GDB</a></h2>
<p>A debugger is a very important component of embedded development as you may not
always have the luxury to log stuff to the host console. In some cases, you may
not even have LEDs to blink on your hardware!</p>
<p>In general, LLDB works as well as GDB when it comes to debugging but we haven't
found an LLDB counterpart to GDB's <code class="hljs">load</code> command, which uploads the program to
the target hardware, so currently we recommend that you use GDB.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#openocd" id="openocd">OpenOCD</a></h2>
<p>GDB isn't able to communicate directly with the ST-Link debugging hardware on
your STM32F3DISCOVERY development board. It needs a translator and the Open
On-Chip Debugger, OpenOCD, is that translator. OpenOCD is a program that runs
on your laptop/PC and translates between GDB's TCP/IP based remote debug
protocol and ST-Link's USB based protocol.</p>
<p>OpenOCD also performs other important work as part of its translation for the
debugging of the ARM Cortex-M based microcontroller on your STM32F3DISCOVERY
development board:</p>
<ul>
<li>It knows how to interact with the memory mapped registers used by the ARM
CoreSight debug peripheral. It is these CoreSight registers that allow for:
<ul>
<li>Breakpoint/Watchpoint manipulation</li>
<li>Reading and writing of the CPU registers</li>
<li>Detecting when the CPU has been halted for a debug event</li>
<li>Continuing CPU execution after a debug event has been encountered</li>
<li>etc.</li>
</ul>
</li>
<li>It also knows how to erase and write to the microcontroller's FLASH</li>
</ul>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#installing-the-tools" id="installing-the-tools">Installing the tools</a></h1>
<p>This page contains OS-agnostic installation instructions for a few of the tools:</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#rust-toolchain" id="rust-toolchain">Rust Toolchain</a></h3>
<p>Install rustup by following the instructions at <a href="https://rustup.rs/">https://rustup.rs</a>.</p>
<p><strong>NOTE</strong> Make sure you have a compiler version equal to or newer than <code class="hljs">1.31</code>. <code class="hljs">rustc -V</code> should return a date newer than the one shown below.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustc -V</span>
rustc 1.31.1 (b6c32da9b 2018-12-18)
</code></pre>
<p>For bandwidth and disk usage concerns the default installation only supports
native compilation. To add cross compilation support for the ARM Cortex-M
architectures choose one of the following compilation targets. For the STM32F3DISCOVERY
board used for the examples in this book, use the final <code class="hljs">thumbv7em-none-eabihf</code> target.</p>
<p>Cortex-M0, M0+, and M1 (ARMv6-M architecture):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustup target add thumbv6m-none-eabi</span>
</code></pre>
<p>Cortex-M3 (ARMv7-M architecture):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustup target add thumbv7m-none-eabi</span>
</code></pre>
<p>Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustup target add thumbv7em-none-eabi</span>
</code></pre>
<p>Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> rustup target add thumbv7em-none-eabihf</span>
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#cargo-binutils-1" id="cargo-binutils-1"><code class="hljs">cargo-binutils</code></a></h3>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo install cargo-binutils</span>
<span class="hljs-meta">
$</span><span class="bash"> rustup component add llvm-tools-preview</span>
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#os-specific-instructions" id="os-specific-instructions">OS-Specific Instructions</a></h3>
<p>Now follow the instructions specific to the OS you are using:</p>
<ul>
<li><a href="https://rust-embedded.github.io/book/intro/install/linux.html">Linux</a></li>
<li><a href="https://rust-embedded.github.io/book/intro/install/windows.html">Windows</a></li>
<li><a href="https://rust-embedded.github.io/book/intro/install/macos.html">macOS</a></li>
</ul>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#linux" id="linux">Linux</a></h1>
<p>Here are the installation commands for a few Linux distributions.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#packages" id="packages">Packages</a></h2>
<ul>
<li>Ubuntu 18.04 or newer / Debian stretch or newer</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code class="hljs">gdb-multiarch</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<!-- Debian stretch -->
<!-- GDB 7.12 -->
<!-- OpenOCD 0.9.0 -->
<!-- QEMU 2.8.1 -->
<!-- Ubuntu 18.04 -->
<!-- GDB 8.1 -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.11.1 -->
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">sudo apt install gdb-multiarch openocd qemu-system-arm
</code></pre>
<ul>
<li>Ubuntu 14.04 and 16.04</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code class="hljs">arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<!-- Ubuntu 14.04 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.7.0 (?) -->
<!-- QEMU 2.0.0 (?) -->
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">sudo apt install gdb-arm-none-eabi openocd qemu-system-arm
</code></pre>
<ul>
<li>Fedora 27 or newer</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code class="hljs">arm-none-eabi-gdb</code> is the GDB command you'll use to debug your ARM
Cortex-M programs</p>
</blockquote>
<!-- Fedora 27 -->
<!-- GDB 7.6 (!) -->
<!-- OpenOCD 0.10.0 -->
<!-- QEMU 2.10.2 -->
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">sudo dnf install arm-none-eabi-gdb openocd qemu-system-arm
</code></pre>
<ul>
<li>Arch Linux</li>
</ul>
<blockquote>
<p><strong>NOTE</strong> <code class="hljs">arm-none-eabi-gdb</code> is the GDB command you'll use to debug ARM
Cortex-M programs</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">sudo pacman -S arm-none-eabi-gdb qemu-arch-extra openocd
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#udev-rules" id="udev-rules">udev rules</a></h2>
<p>This rule lets you use OpenOCD with the Discovery board without root privilege.</p>
<p>Create the file <code class="hljs">/etc/udev/rules.d/70-st-link.rules</code> with the contents shown below.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs"># STM32F3DISCOVERY rev A/B - ST-LINK/V2
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="3748", TAG+="uaccess"

# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1
ATTRS{idVendor}=="0483", ATTRS{idProduct}=="374b", TAG+="uaccess"
</code></pre>
<p>Then reload all the udev rules with:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">sudo udevadm control --reload-rules
</code></pre>
<p>If you had the board plugged to your laptop, unplug it and then plug it again.</p>
<p>You can check the permissions by running this command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">lsusb
</code></pre>
<p>Which should show something like</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">(..)
Bus 001 Device 018: ID 0483:374b STMicroelectronics ST-LINK/V2.1
(..)
</code></pre>
<p>Take note of the bus and device numbers. Use those numbers to create a path like
<code class="hljs">/dev/bus/usb/&lt;bus&gt;/&lt;device&gt;</code>. Then use this path like so:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">ls -l /dev/bus/usb/001/018
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">crw-------+ 1 root root 189, 17 Sep 13 12:34 /dev/bus/usb/001/018
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">getfacl /dev/bus/usb/001/018 | grep user
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">user::rw-
user:you:rw-
</code></pre>
<p>The <code class="hljs">+</code> appended to permissions indicates the existence of an extended
permission. The <code class="hljs">getfacl</code> command tells the user <code class="hljs">you</code> can make use of
this device.</p>
<p>Now, go to the <a href="https://rust-embedded.github.io/book/intro/install/verify.html">next section</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#macos" id="macos">macOS</a></h1>
<p>All the tools can be install using <a href="http://brew.sh/">Homebrew</a>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># GDB</span></span>
<span class="hljs-meta">$</span><span class="bash"> brew install armmbed/formulae/arm-none-eabi-gcc</span>
<span class="hljs-meta">
$</span><span class="bash"> <span class="hljs-comment"># OpenOCD</span></span>
<span class="hljs-meta">$</span><span class="bash"> brew install openocd</span>
<span class="hljs-meta">
$</span><span class="bash"> <span class="hljs-comment"># QEMU</span></span>
<span class="hljs-meta">$</span><span class="bash"> brew install qemu</span>
</code></pre>
<p>That's all! Go to the <a href="https://rust-embedded.github.io/book/intro/install/verify.html">next section</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#windows" id="windows">Windows</a></h1>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#arm-none-eabi-gdb" id="arm-none-eabi-gdb"><code class="hljs">arm-none-eabi-gdb</code></a></h2>
<p>ARM provides <code class="hljs">.exe</code> installers for Windows. Grab one from <a href="https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads">here</a>, and follow the instructions.
Just before the installation process finishes tick/select the "Add path to environment variable"
option. Then verify that the tools are in your <code class="hljs">%PATH%</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> arm-none-eabi-gdb -v</span>
GNU gdb (GNU Tools for Arm Embedded Processors 7-2018-q2-update) 8.1.0.20180315-git
(..)
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#openocd-1" id="openocd-1">OpenOCD</a></h2>
<p>There's no official binary release of OpenOCD for Windows but there are unofficial releases
available <a href="https://github.com/gnu-mcu-eclipse/openocd/releases">here</a>. Grab the 0.10.x zipfile and extract it somewhere on your drive (I
recommend <code class="hljs">C:\OpenOCD</code> but with the drive letter that makes sense to you) then update your <code class="hljs">%PATH%</code>
environment variable to include the following path: <code class="hljs">C:\OpenOCD\bin</code> (or the path that you used
before).</p>
<p>Verify that OpenOCD is in your <code class="hljs">%PATH%</code> with:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd -v</span>
Open On-Chip Debugger 0.10.0
(..)
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#qemu" id="qemu">QEMU</a></h2>
<p>Grab QEMU from <a href="https://www.qemu.org/download/#windows">the official website</a>.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#st-link-usb-driver" id="st-link-usb-driver">ST-LINK USB driver</a></h2>
<p>You'll also need to install <a href="http://www.st.com/en/embedded-software/stsw-link009.html">this USB driver</a> or OpenOCD won't work. Follow the installer
instructions and make sure you install the right version (32-bit or 64-bit) of the driver.</p>
<p>That's all! Go to the <a href="https://rust-embedded.github.io/book/intro/install/verify.html">next section</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#verify-installation" id="verify-installation">Verify Installation</a></h1>
<p>In this section we check that some of the required tools / drivers have been
correctly installed and configured.</p>
<p>Connect your laptop / PC to the discovery board using a micro USB cable. The
discovery board has two USB connectors; use the one labeled "USB ST-LINK" that
sits on the center of the edge of the board.</p>
<p>Also check that the ST-LINK header is populated. See the picture below; the
ST-LINK header is circled in red.</p>
<p align="center">
<img title="Connected discovery board" src="./The Embedded Rust Book_files/verify.jpeg">
</p>
<p>Now run the following command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd -f interface/stlink-v2-1.cfg -f target/stm32f3x.cfg</span>
</code></pre>
<p>You should get the following output and the program should block the console:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.919881
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>The contents may not match exactly but you should get the last line about
breakpoints and watchpoints. If you got it then terminate the OpenOCD process
and move to the <a href="https://rust-embedded.github.io/book/start/index.html">next section</a>.</p>
<p>If you didn't get the "breakpoints" line then try the following command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd -f interface/stlink-v2.cfg -f target/stm32f3x.cfg</span>
</code></pre>
<p>If that command works that means you got an old hardware revision of the
discovery board. That won't be a problem but commit that fact to memory as
you'll need to configure things a bit differently later on. You can move to the
<a href="https://rust-embedded.github.io/book/start/index.html">next section</a>.</p>
<p>If neither command worked as a normal user then try to run them with root
permission (e.g. <code class="hljs">sudo openocd ..</code>). If the commands do work with root
permission then check that the <a href="https://rust-embedded.github.io/book/intro/install/linux.html#udev-rules">udev rules</a> have been correctly set.</p>
<p>If you have reached this point and OpenOCD is not working please open <a href="https://github.com/rust-embedded/book/issues">an issue</a>
and we'll help you out!</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#getting-started" id="getting-started">Getting Started</a></h1>
<p>In this section we'll walk you through the process of writing, building,
flashing and debugging embedded programs. You will be able to try most of the
examples without any special hardware as we will show you the basics using
QEMU, a popular open-source hardware emulator. The only section where hardware
is required is, naturally enough, the <a href="https://rust-embedded.github.io/book/start/hardware.html">Hardware</a> section,
where we use OpenOCD to program an <a href="http://www.st.com/en/evaluation-tools/stm32f3discovery.html">STM32F3DISCOVERY</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#qemu-1" id="qemu-1">QEMU</a></h1>
<p>We'll start writing a program for the <a href="http://www.ti.com/product/LM3S6965">LM3S6965</a>, a Cortex-M3 microcontroller.
We have chosen this as our initial target because it <a href="https://wiki.qemu.org/Documentation/Platforms/ARM#Supported_in_qemu-system-arm">can be emulated</a> using QEMU
so you don't need to fiddle with hardware in this section and we can focus on
the tooling and the development process.</p>
<p><strong>IMPORTANT</strong>
We'll use the name "app" for the project name in this tutorial.
Whenever you see the word "app" you should replace it with the name you selected
for your project. Or, you could also name your project "app" and avoid the
substitutions.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#creating-a-non-standard-rust-program" id="creating-a-non-standard-rust-program">Creating a non standard Rust program</a></h2>
<p>We'll use the <a href="https://github.com/rust-embedded/cortex-m-quickstart"><code class="hljs">cortex-m-quickstart</code></a> project template to generate a new
project from it.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#using-cargo-generate" id="using-cargo-generate">Using <code class="hljs">cargo-generate</code></a></h3>
<p>First install cargo-generate</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo install cargo-generate
</code></pre>
<p>Then generate a new project</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs"> Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cd app
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#using-git" id="using-git">Using <code class="hljs">git</code></a></h3>
<p>Clone the repository</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">git clone https://github.com/rust-embedded/cortex-m-quickstart app
cd app
</code></pre>
<p>And then fill in the placeholders in the <code class="hljs">Cargo.toml</code> file</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[package]</span>
<span class="hljs-attr">authors</span> = [<span class="hljs-string">"{{authors}}"</span>] <span class="hljs-comment"># "{{authors}}" -&gt; "John Smith"</span>
<span class="hljs-attr">edition</span> = <span class="hljs-string">"2018"</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"{{project-name}}"</span> <span class="hljs-comment"># "{{project-name}}" -&gt; "awesome-app"</span>
<span class="hljs-attr">version</span> = <span class="hljs-string">"0.1.0"</span>

<span class="hljs-comment"># ..</span>
<span class="hljs-section">
[[bin]]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"{{project-name}}"</span> <span class="hljs-comment"># "{{project-name}}" -&gt; "awesome-app"</span>
<span class="hljs-attr">test</span> = <span class="hljs-literal">false</span>
<span class="hljs-attr">bench</span> = <span class="hljs-literal">false</span>
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#using-neither" id="using-neither">Using neither</a></h3>
<p>Grab the latest snapshot of the <code class="hljs">cortex-m-quickstart</code> template and extract it.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/master.zip
unzip master.zip
mv cortex-m-quickstart-master app
cd app
</code></pre>
<p>Or you can browse to <a href="https://github.com/rust-embedded/cortex-m-quickstart"><code class="hljs">cortex-m-quickstart</code></a>, click the green "Clone or
download" button and then click "Download ZIP".</p>
<p>Then fill in the placeholders in the <code class="hljs">Cargo.toml</code> file as done in the second
part of the "Using <code class="hljs">git</code>" version.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#program-overview" id="program-overview">Program Overview</a></h2>
<p>For convenience here are the most important parts of the source code in <code class="hljs">src/main.rs</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> cortex_m_rt::entry;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// your code goes here</span>
    }
}
</code></pre>
<p>This program is a bit different from a standard Rust program so let's take a
closer look.</p>
<p><code class="hljs">#![no_std]</code> indicates that this program will <em>not</em> link to the standard crate,
<code class="hljs">std</code>. Instead it will link to its subset: the <code class="hljs">core</code> crate.</p>
<p><code class="hljs">#![no_main]</code> indicates that this program won't use the standard <code class="hljs">main</code>
interface that most Rust programs use. The main (no pun intended) reason to go
with <code class="hljs">no_main</code> is that using the <code class="hljs">main</code> interface in <code class="hljs">no_std</code> context requires
nightly.</p>
<p><code class="hljs">extern crate panic_halt;</code>. This crate provides a <code class="hljs">panic_handler</code> that defines
the panicking behavior of the program. We will cover this in more detail in the
<a href="https://rust-embedded.github.io/book/start/panicking.html">Panicking</a> chapter of the book.</p>
<p><a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html"><code class="hljs">#[entry]</code></a> is an attribute provided by the <a href="https://crates.io/crates/cortex-m-rt"><code class="hljs">cortex-m-rt</code></a> crate that's used
to mark the entry point of the program. As we are not using the standard <code class="hljs">main</code>
interface we need another way to indicate the entry point of the program and
that'd be <code class="hljs">#[entry]</code>.</p>
<p><code class="hljs">fn main() -&gt; !</code>. Our program will be the <em>only</em> process running on the target
hardware so we don't want it to end! We use a <a href="https://doc.rust-lang.org/rust-by-example/fn/diverging.html">divergent function</a> (the <code class="hljs">-&gt; !</code>
bit in the function signature) to ensure at compile time that'll be the case.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#cross-compiling" id="cross-compiling">Cross compiling</a></h2>
<p>The next step is to <em>cross</em> compile the program for the Cortex-M3 architecture.
That's as simple as running <code class="hljs">cargo build --target $TRIPLE</code> if you know what the
compilation target (<code class="hljs">$TRIPLE</code>) should be. Luckily, the <code class="hljs">.cargo/config</code> in the
template has the answer:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">tail -n6 .cargo/config
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[build]</span>
<span class="hljs-comment"># Pick ONE of these compilation targets</span>
<span class="hljs-comment"># target = "thumbv6m-none-eabi"    # Cortex-M0 and Cortex-M0+</span>
<span class="hljs-attr">target</span> = <span class="hljs-string">"thumbv7m-none-eabi"</span>    <span class="hljs-comment"># Cortex-M3</span>
<span class="hljs-comment"># target = "thumbv7em-none-eabi"   # Cortex-M4 and Cortex-M7 (no FPU)</span>
<span class="hljs-comment"># target = "thumbv7em-none-eabihf" # Cortex-M4F and Cortex-M7F (with FPU)</span>
</code></pre>
<p>To cross compile for the Cortex-M3 architecture we have to use
<code class="hljs">thumbv7m-none-eabi</code>. This compilation target has been set as the default so the
two commands below do the same:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo build --target thumbv7m-none-eabi
cargo build
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#inspecting" id="inspecting">Inspecting</a></h2>
<p>Now we have a non-native ELF binary in <code class="hljs">target/thumbv7m-none-eabi/debug/app</code>. We
can inspect it using <code class="hljs">cargo-binutils</code>.</p>
<p>With <code class="hljs">cargo-readobj</code> we can print the ELF headers to confirm that this is an ARM
binary.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo readobj --bin app -- -file-headers
</code></pre>
<p>Note that:</p>
<ul>
<li><code class="hljs">--bin app</code> is sugar for inspect the binary at <code class="hljs">target/$TRIPLE/debug/app</code></li>
<li><code class="hljs">--bin app</code> will also (re)compile the binary, if necessary</li>
</ul>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0x0
  Type:                              EXEC (Executable file)
  Machine:                           ARM
  Version:                           0x1
  Entry point address:               0x405
  Start of program headers:          52 (bytes into file)
  Start of section headers:          153204 (bytes into file)
  Flags:                             0x5000200
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         19
  Section header string table index: 18
</code></pre>
<p><code class="hljs">cargo-size</code> can print the size of the linker sections of the binary.</p>
<blockquote>
<p><strong>NOTE</strong> this output assumes that rust-embedded/cortex-m-rt#111 has been
merged</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo size --bin app --release -- -A
</code></pre>
<p>we use <code class="hljs">--release</code> to inspect the optimized version</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">app  :
section             size        addr
.vector_table       1024         0x0
.text                 92       0x400
.rodata                0       0x45c
.data                  0  0x20000000
.bss                   0  0x20000000
.debug_str          2958         0x0
.debug_loc            19         0x0
.debug_abbrev        567         0x0
.debug_info         4929         0x0
.debug_ranges         40         0x0
.debug_macinfo         1         0x0
.debug_pubnames     2035         0x0
.debug_pubtypes     1892         0x0
.ARM.attributes       46         0x0
.debug_frame         100         0x0
.debug_line          867         0x0
Total              14570
</code></pre>
<blockquote>
<p>A refresher on ELF linker sections</p>
<ul>
<li><code class="hljs">.text</code> contains the program instructions</li>
<li><code class="hljs">.rodata</code> contains constant values like strings</li>
<li><code class="hljs">.data</code> contains statically allocated variables whose initial values are
<em>not</em> zero</li>
<li><code class="hljs">.bss</code> also contains statically allocated variables whose initial values
<em>are</em> zero</li>
<li><code class="hljs">.vector_table</code> is a <em>non</em>-standard section that we use to store the vector
(interrupt) table</li>
<li><code class="hljs">.ARM.attributes</code> and the <code class="hljs">.debug_*</code> sections contain metadata and will
<em>not</em> be loaded onto the target when flashing the binary.</li>
</ul>
</blockquote>
<p><strong>IMPORTANT</strong>: ELF files contain metadata like debug information so their <em>size
on disk</em> does <em>not</em> accurately reflect the space the program will occupy when
flashed on a device. <em>Always</em> use <code class="hljs">cargo-size</code> to check how big a binary really
is.</p>
<p><code class="hljs">cargo-objdump</code> can be used to disassemble the binary.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo objdump --bin app --release -- -disassemble -no-show-raw-insn -print-imm-hex
</code></pre>
<blockquote>
<p><strong>NOTE</strong> this output can differ on your system. New versions of rustc, LLVM
and libraries can generate different assembly. We truncated some of the instructions
to keep the snippet small.</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">app:  file format ELF32-arm-little

Disassembly of section .text:
main:
     400: bl  #0x256
     404: b #-0x4 &lt;main+0x4&gt;

Reset:
     406: bl  #0x24e
     40a: movw  r0, #0x0
     &lt; .. truncated any more instructions .. &gt;

DefaultHandler_:
     656: b #-0x4 &lt;DefaultHandler_&gt;

UsageFault:
     657: strb  r7, [r4, #0x3]

DefaultPreInit:
     658: bx  lr

__pre_init:
     659: strb  r7, [r0, #0x1]

__nop:
     65a: bx  lr

HardFaultTrampoline:
     65c: mrs r0, msp
     660: b #-0x2 &lt;HardFault_&gt;

HardFault_:
     662: b #-0x4 &lt;HardFault_&gt;

HardFault:
     663: &lt;unknown&gt;
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#running" id="running">Running</a></h2>
<p>Next, let's see how to run an embedded program on QEMU! This time we'll use the
<code class="hljs">hello</code> example which actually does something.</p>
<p>For convenience here's the source code of <code class="hljs">examples/hello.rs</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">//! Prints "Hello, world!" on the host console using semihosting</span>

<span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> cortex_m_semihosting::{debug, hprintln};

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    hprintln!(<span class="hljs-string">"Hello, world!"</span>).unwrap();

    <span class="hljs-comment">// exit QEMU</span>
    <span class="hljs-comment">// NOTE do not run this on hardware; it can corrupt OpenOCD state</span>
    debug::exit(debug::EXIT_SUCCESS);

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>This program uses something called semihosting to print text to the <em>host</em>
console. When using real hardware this requires a debug session but when using
QEMU this Just Works.</p>
<p>Let's start by compiling the example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo build --example hello
</code></pre>
<p>The output binary will be located at
<code class="hljs">target/thumbv7m-none-eabi/debug/examples/hello</code>.</p>
<p>To run this binary on QEMU run the following command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">qemu-system-arm \
  -cpu cortex-m3 \
  -machine lm3s6965evb \
  -nographic \
  -semihosting-config enable=on,target=native \
  -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">Hello, world!
</code></pre>
<p>The command should successfully exit (exit code = 0) after printing the text. On
*nix you can check that with the following command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">echo $?
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">0
</code></pre>
<p>Let's break down that QEMU command:</p>
<ul>
<li>
<p><code class="hljs">qemu-system-arm</code>. This is the QEMU emulator. There are a few variants of
these QEMU binaries; this one does full <em>system</em> emulation of <em>ARM</em> machines
hence the name.</p>
</li>
<li>
<p><code class="hljs">-cpu cortex-m3</code>. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the
CPU model lets us catch some miscompilation errors: for example, running a
program compiled for the Cortex-M4F, which has a hardware FPU, will make QEMU
error during its execution.</p>
</li>
<li>
<p><code class="hljs">-machine lm3s6965evb</code>. This tells QEMU to emulate the LM3S6965EVB, a
evaluation board that contains a LM3S6965 microcontroller.</p>
</li>
<li>
<p><code class="hljs">-nographic</code>. This tells QEMU to not launch its GUI.</p>
</li>
<li>
<p><code class="hljs">-semihosting-config (..)</code>. This tells QEMU to enable semihosting. Semihosting
lets the emulated device, among other things, use the host stdout, stderr and
stdin and create files on the host.</p>
</li>
<li>
<p><code class="hljs">-kernel $file</code>. This tells QEMU which binary to load and run on the emulated
machine.</p>
</li>
</ul>
<p>Typing out that long QEMU command is too much work! We can set a custom runner
to simplify the process. <code class="hljs">.cargo/config</code> has a commented out runner that invokes
QEMU; let's uncomment it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">head -n3 .cargo/config
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[target.thumbv7m-none-eabi]</span>
<span class="hljs-comment"># uncomment this to make `cargo run` execute programs on QEMU</span>
<span class="hljs-attr">runner</span> = <span class="hljs-string">"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"</span>
</code></pre>
<p>This runner only applies to the <code class="hljs">thumbv7m-none-eabi</code> target, which is our
default compilation target. Now <code class="hljs">cargo run</code> will compile the program and run it
on QEMU:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">cargo run --example hello --release
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">   Compiling app v0.1.0 (file:///tmp/app)
    Finished release [optimized + debuginfo] target(s) in 0.26s
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel target/thumbv7m-none-eabi/release/examples/hello`
Hello, world!
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#debugging" id="debugging">Debugging</a></h2>
<p>Debugging is critical to embedded development. Let's see how it's done.</p>
<p>Debugging an embedded device involves <em>remote</em> debugging as the program that we
want to debug won't be running on the machine that's running the debugger
program (GDB or LLDB).</p>
<p>Remote debugging involves a client and a server. In a QEMU setup, the client
will be a GDB (or LLDB) process and the server will be the QEMU process that's
also running the embedded program.</p>
<p>In this section we'll use the <code class="hljs">hello</code> example we already compiled.</p>
<p>The first debugging step is to launch QEMU in debugging mode:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">qemu-system-arm \
  -cpu cortex-m3 \
  -machine lm3s6965evb \
  -nographic \
  -semihosting-config enable=on,target=native \
  -gdb tcp::3333 \
  -S \
  -kernel target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<p>This command won't print anything to the console and will block the terminal. We
have passed two extra flags this time:</p>
<ul>
<li>
<p><code class="hljs">-gdb tcp::3333</code>. This tells QEMU to wait for a GDB connection on TCP
port 3333.</p>
</li>
<li>
<p><code class="hljs">-S</code>. This tells QEMU to freeze the machine at startup. Without this the
program would have reached the end of main before we had a chance to launch
the debugger!</p>
</li>
</ul>
<p>Next we launch GDB in another terminal and tell it to load the debug symbols of
the example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">gdb-multiarch -q target/thumbv7m-none-eabi/debug/examples/hello
</code></pre>
<p><strong>NOTE</strong>: you might need another version of gdb instead of <code class="hljs">gdb-multiarch</code> depending
on which one you installed in the installation chapter. This could also be
<code class="hljs">arm-none-eabi-gdb</code> or just <code class="hljs">gdb</code>.</p>
<p>Then within the GDB shell we connect to QEMU, which is waiting for a connection
on TCP port 3333.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">target remote :3333
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">Remote debugging using :3333
Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473
473     pub unsafe extern "C" fn Reset() -&gt; ! {
</code></pre>
<p>You'll see that the process is halted and that the program counter is pointing
to a function named <code class="hljs">Reset</code>. That is the reset handler: what Cortex-M cores
execute upon booting.</p>
<p>This reset handler will eventually call our main function. Let's skip all the
way there using a breakpoint and the <code class="hljs">continue</code> command:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">break main
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">Breakpoint 1 at 0x400: file examples/panic.rs, line 29.
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">continue
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">Continuing.

Breakpoint 1, main () at examples/hello.rs:17
17          let mut stdout = hio::hstdout().unwrap();
</code></pre>
<p>We are now close to the code that prints "Hello, world!". Let's move forward
using the <code class="hljs">next</code> command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">next
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">18          writeln!(stdout, "Hello, world!").unwrap();
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">next
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">20          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<p>At this point you should see "Hello, world!" printed on the terminal that's
running <code class="hljs">qemu-system-arm</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">$ qemu-system-arm (..)
Hello, world!
</code></pre>
<p>Calling <code class="hljs">next</code> again will terminate the QEMU process.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">next
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">[Inferior 1 (Remote target) exited normally]
</code></pre>
<p>You can now exit the GDB session.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">quit
</code></pre>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#hardware" id="hardware">Hardware</a></h1>
<p>By now you should be somewhat familiar with the tooling and the development
process. In this section we'll switch to real hardware; the process will remain
largely the same. Let's dive in.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#know-your-hardware" id="know-your-hardware">Know your hardware</a></h2>
<p>Before we begin you need to identify some characteristics of the target device
as these will be used to configure the project:</p>
<ul>
<li>
<p>The ARM core. e.g. Cortex-M3.</p>
</li>
<li>
<p>Does the ARM core include an FPU? Cortex-M4<strong>F</strong> and Cortex-M7<strong>F</strong> cores do.</p>
</li>
<li>
<p>How much Flash memory and RAM does the target device have? e.g. 256 KiB of
Flash and 32 KiB of RAM.</p>
</li>
<li>
<p>Where are Flash memory and RAM mapped in the address space? e.g. RAM is
commonly located at address <code class="hljs">0x2000_0000</code>.</p>
</li>
</ul>
<p>You can find this information in the data sheet or the reference manual of your
device.</p>
<p>In this section we'll be using our reference hardware, the STM32F3DISCOVERY.
This board contains an STM32F303VCT6 microcontroller. This microcontroller has:</p>
<ul>
<li>
<p>A Cortex-M4F core that includes a single precision FPU</p>
</li>
<li>
<p>256 KiB of Flash located at address 0x0800_0000.</p>
</li>
<li>
<p>40 KiB of RAM located at address 0x2000_0000. (There's another RAM region but
for simplicity we'll ignore it).</p>
</li>
</ul>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#configuring" id="configuring">Configuring</a></h2>
<p>We'll start from scratch with a fresh template instance. Refer to the
<a href="https://rust-embedded.github.io/book/start/qemu.html">previous section on QEMU</a> for a refresher on how to do this without
<code class="hljs">cargo-generate</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart</span>
 Project Name: app
 Creating project called `app`...
 Done! New project created /tmp/app
<span class="hljs-meta">
 $</span><span class="bash"> <span class="hljs-built_in">cd</span> app</span>
</code></pre>
<p>Step number one is to set a default compilation target in <code class="hljs">.cargo/config</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> tail -n5 .cargo/config</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-comment"># Pick ONE of these compilation targets</span>
<span class="hljs-comment"># target = "thumbv6m-none-eabi"    # Cortex-M0 and Cortex-M0+</span>
<span class="hljs-comment"># target = "thumbv7m-none-eabi"    # Cortex-M3</span>
<span class="hljs-comment"># target = "thumbv7em-none-eabi"   # Cortex-M4 and Cortex-M7 (no FPU)</span>
<span class="hljs-attr">target</span> = <span class="hljs-string">"thumbv7em-none-eabihf"</span> <span class="hljs-comment"># Cortex-M4F and Cortex-M7F (with FPU)</span>
</code></pre>
<p>We'll use <code class="hljs">thumbv7em-none-eabihf</code> as that covers the Cortex-M4F core.</p>
<p>The second step is to enter the memory region information into the <code class="hljs">memory.x</code>
file.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat memory.x</span>
/* Linker script for the STM32F303VCT6 */
MEMORY
{
  /* NOTE 1 K = 1 KiBi = 1024 bytes */
  FLASH : ORIGIN = 0x08000000, LENGTH = 256K
  RAM : ORIGIN = 0x20000000, LENGTH = 40K
}
</code></pre>
<p>Make sure the <code class="hljs">debug::exit()</code> call is commented out or removed, it is used
only for running in QEMU.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    hprintln!(<span class="hljs-string">"Hello, world!"</span>).unwrap();

    <span class="hljs-comment">// exit QEMU</span>
    <span class="hljs-comment">// NOTE do not run this on hardware; it can corrupt OpenOCD state</span>
    <span class="hljs-comment">// debug::exit(debug::EXIT_SUCCESS);</span>

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>You can now cross compile programs using <code class="hljs">cargo build</code>
and inspect the binaries using <code class="hljs">cargo-binutils</code> as you did before. The
<code class="hljs">cortex-m-rt</code> crate handles all the magic required to get your chip running,
as helpfully, pretty much all Cortex-M CPUs boot in the same fashion.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo build --example hello</span>
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#debugging-1" id="debugging-1">Debugging</a></h2>
<p>Debugging will look a bit different. In fact, the first steps can look different
depending on the target device. In this section we'll show the steps required to
debug a program running on the STM32F3DISCOVERY. This is meant to serve as a
reference; for device specific information about debugging check out <a href="https://github.com/rust-embedded/debugonomicon">the
Debugonomicon</a>.</p>
<p>As before we'll do remote debugging and the client will be a GDB process. This
time, however, the server will be OpenOCD.</p>
<p>As done during the <a href="https://rust-embedded.github.io/book/intro/install/verify.html">verify</a> section connect the discovery board to your laptop /
PC and check that the ST-LINK header is populated.</p>
<p>On a terminal run <code class="hljs">openocd</code> to connect to the ST-LINK on the discovery board.
Run this command from the root of the template; <code class="hljs">openocd</code> will pick up the
<code class="hljs">openocd.cfg</code> file which indicates which interface file and target file to use.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat openocd.cfg</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs"># Sample OpenOCD configuration for the STM32F3DISCOVERY development board

# Depending on the hardware revision you got you'll have to pick ONE of these
# interfaces. At any time only one interface should be commented out.

# Revision C (newer revision)
source [find interface/stlink-v2-1.cfg]

# Revision A and B (older revisions)
# source [find interface/stlink-v2.cfg]

source [find target/stm32f3x.cfg]
</code></pre>
<blockquote>
<p><strong>NOTE</strong> If you found out that you have an older revision of the discovery
board during the <a href="https://rust-embedded.github.io/book/intro/install/verify.html">verify</a> section then you should modify the <code class="hljs">openocd.cfg</code>
file at this point to use <code class="hljs">interface/stlink-v2.cfg</code>.</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd</span>
Open On-Chip Debugger 0.10.0
Licensed under GNU GPL v2
For bug reports, read
        http://openocd.org/doc/doxygen/bugs.html
Info : auto-selecting first available session transport "hla_swd". To override use 'transport select &lt;transport&gt;'.
adapter speed: 1000 kHz
adapter_nsrst_delay: 100
Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD
none separate
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : Unable to match requested speed 1000 kHz, using 950 kHz
Info : clock speed 950 kHz
Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B
Info : using stlink api v2
Info : Target voltage: 2.913879
Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints
</code></pre>
<p>On another terminal run GDB, also from the root of the template.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> &lt;gdb&gt; -q target/thumbv7em-none-eabihf/debug/examples/hello</span>
</code></pre>
<p>Next connect GDB to OpenOCD, which is waiting for a TCP connection on port 3333.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) target remote :3333
Remote debugging using :3333
0x00000000 in ?? ()
</code></pre>
<p>Now proceed to <em>flash</em> (load) the program onto the microcontroller using the
<code class="hljs">load</code> command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) load
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
</code></pre>
<p>The program is now loaded. This program uses semihosting so before we do any
semihosting call we have to tell OpenOCD to enable semihosting. You can send
commands to OpenOCD using the <code class="hljs">monitor</code> command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<blockquote>
<p>You can see all the OpenOCD commands by invoking the <code class="hljs">monitor help</code> command.</p>
</blockquote>
<p>Like before we can skip all the way to <code class="hljs">main</code> using a breakpoint and the
<code class="hljs">continue</code> command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) break main
Breakpoint 1 at 0x8000d18: file examples/hello.rs, line 15.

(gdb) continue
Continuing.
Note: automatically using hardware breakpoints for read-only addresses.

Breakpoint 1, main () at examples/hello.rs:15
15          let mut stdout = hio::hstdout().unwrap();
</code></pre>
<p>Advancing the program with <code class="hljs">next</code> should produce the same results as before.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) next
16          writeln!(stdout, "Hello, world!").unwrap();

(gdb) next
19          debug::exit(debug::EXIT_SUCCESS);
</code></pre>
<p>At this point you should see "Hello, world!" printed on the OpenOCD console,
among other stuff.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd</span>
(..)
Info : halted: PC: 0x08000e6c
Hello, world!
Info : halted: PC: 0x08000d62
Info : halted: PC: 0x08000d64
Info : halted: PC: 0x08000d66
Info : halted: PC: 0x08000d6a
Info : halted: PC: 0x08000a0c
Info : halted: PC: 0x08000d70
Info : halted: PC: 0x08000d72
</code></pre>
<p>Issuing another <code class="hljs">next</code> will make the processor execute <code class="hljs">debug::exit</code>. This acts
as a breakpoint and halts the process:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) next

Program received signal SIGTRAP, Trace/breakpoint trap.
0x0800141a in __syscall ()
</code></pre>
<p>It also causes this to be printed to the OpenOCD console:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd</span>
(..)
Info : halted: PC: 0x08001188
semihosting: *** application exited ***
Warn : target not halted
Warn : target not halted
target halted due to breakpoint, current mode: Thread
xPSR: 0x21000000 pc: 0x08000d76 msp: 0x20009fc0, semihosting
</code></pre>
<p>However, the process running on the microcontroller has not terminated and you
can resume it using <code class="hljs">continue</code> or a similar command.</p>
<p>You can now exit GDB using the <code class="hljs">quit</code> command.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) quit
</code></pre>
<p>Debugging now requires a few more steps so we have packed all those steps into a
single GDB script named <code class="hljs">openocd.gdb</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cat openocd.gdb</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-text hljs">target remote :3333

# print demangled symbols
set print asm-demangle on

# detect unhandled exceptions, hard faults and panics
break DefaultHandler
break HardFault
break rust_begin_unwind

monitor arm semihosting enable

load

# start the process but immediately halt the processor
stepi
</code></pre>
<p>Now running <code class="hljs">&lt;gdb&gt; -x openocd.gdb $program</code> will immediately connect GDB to
OpenOCD, enable semihosting, load the program and start the process.</p>
<p>Alternatively, you can turn <code class="hljs">&lt;gdb&gt; -x openocd.gdb</code> into a custom runner to make
<code class="hljs">cargo run</code> build a program <em>and</em> start a GDB session. This runner is included
in <code class="hljs">.cargo/config</code> but it's commented out.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> head -n10 .cargo/config</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[target.thumbv7m-none-eabi]</span>
<span class="hljs-comment"># uncomment this to make `cargo run` execute programs on QEMU</span>
<span class="hljs-comment"># runner = "qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic -semihosting-config enable=on,target=native -kernel"</span>
<span class="hljs-section">
[target.'cfg(all(target_arch = "arm", target_os = "none"))']</span>
<span class="hljs-comment"># uncomment ONE of these three option to make `cargo run` start a GDB session</span>
<span class="hljs-comment"># which option to pick depends on your system</span>
<span class="hljs-attr">runner</span> = <span class="hljs-string">"arm-none-eabi-gdb -x openocd.gdb"</span>
<span class="hljs-comment"># runner = "gdb-multiarch -x openocd.gdb"</span>
<span class="hljs-comment"># runner = "gdb -x openocd.gdb"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run --example hello</span>
(..)
Loading section .vector_table, size 0x400 lma 0x8000000
Loading section .text, size 0x1e70 lma 0x8000400
Loading section .rodata, size 0x61c lma 0x8002270
Start address 0x800144e, load size 10380
Transfer rate: 17 KB/sec, 3460 bytes/write.
(gdb)
</code></pre>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#memory-mapped-registers" id="memory-mapped-registers">Memory Mapped Registers</a></h1>
<p>Embedded systems can only get so far by executing normal Rust code and moving data around in RAM. If we want to get any information into or out of our system (be that blinking an LED, detecting a button press or communicating with an off-chip peripheral on some sort of bus) we're going to have to dip into the world of Peripherals and their 'memory mapped registers'.</p>
<p>You may well find that the code you need to access the peripherals in your micro-controller has already been written, at one of the following levels:</p>
<ul>
<li>Micro-architecture Crate - This sort of crate handles any useful routines common to the processor core your microcontroller is using, as well as any peripherals that are common to all micro-controllers that use that particular type of processor core. For example the <a href="https://crates.io/crates/cortex-m">cortex-m</a> crate gives you functions to enable and disable interrupts, which are the same for all Cortex-M based micro-controllers. It also gives you access to the 'SysTick' peripheral included with all Cortex-M based micro-controllers.</li>
<li>Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over the various memory-wrapper registers defined for your particular part-number of micro-controller you are using. For example, <a href="https://crates.io/crates/tm4c123x">tm4c123x</a> for the Texas Instruments Tiva-C TM4C123 series, or <a href="https://crates.io/crates/stm32f30x">stm32f30x</a> for the ST-Micro STM32F30x series. Here, you'll be interacting with the registers directly, following each peripheral's operating instructions given in your micro-controller's Technical Reference Manual.</li>
<li>HAL Crate - These crates offer a more user-friendly API for your particular processor, often by implementing some common traits defined in <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>. For example, this crate might offer a <code class="hljs">Serial</code> struct, with a constructor that takes an appropriate set of GPIO pins and a baud rate, and offers some sort of <code class="hljs">write_byte</code> function for sending data. See the chapter on <a href="https://rust-embedded.github.io/book/portability/index.html">Portability</a> for more information on <a href="https://crates.io/crates/embedded-hal">embedded-hal</a>.</li>
<li>Board Crate - These crates go one step further than a HAL Crate by pre-configuring various peripherals and GPIO pins to suit the specific developer kit or board you are using, such as <a href="https://crates.io/crates/f3">F3</a> for the STM32F3DISCOVERY board.</li>
</ul>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#starting-at-the-bottom" id="starting-at-the-bottom">Starting at the bottom</a></h2>
<p>Let's look at the SysTick peripheral that's common to all Cortex-M based micro-controllers. We can find a pretty low-level API in the <a href="https://crates.io/crates/cortex-m">cortex-m</a> crate, and we can use it like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> cortex_m::peripheral::{syst, Peripherals};
<span class="hljs-keyword">use</span> cortex_m_rt::entry;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> peripherals = Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> systick = peripherals.SYST;
    systick.set_clock_source(syst::SystClkSource::Core);
    systick.set_reload(<span class="hljs-number">1_000</span>);
    systick.clear_current();
    systick.enable_counter();
    <span class="hljs-keyword">while</span> !systick.has_wrapped() {
        <span class="hljs-comment">// Loop</span>
    }

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>The functions on the <code class="hljs">SYST</code> struct map pretty closely to the functionality defined by the ARM Technical Reference Manual for this peripheral. There's nothing in this API about 'delaying for X milliseconds' - we have to crudely implement that ourselves using a <code class="hljs">while</code> loop. Note that we can't access our <code class="hljs">SYST</code> struct until we have called <code class="hljs">Peripherals::take()</code> - this is a special routine that guarantees that there is only one <code class="hljs">SYST</code> structure in our entire program. For more on that, see the <a href="https://rust-embedded.github.io/book/peripherals/index.html">Peripherals</a> section.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#using-a-peripheral-access-crate-pac" id="using-a-peripheral-access-crate-pac">Using a Peripheral Access Crate (PAC)</a></h2>
<p>We won't get very far with our embedded software development if we restrict ourselves to only the basic peripherals included with every Cortex-M. At some point, we're going to need to write some code that's specific to the particular micro-controller we're using. In this example, let's assume we have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB of Flash. We're going to pull in the <a href="https://crates.io/crates/tm4c123x">tm4c123x</a> crate to make use of this chip.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt; <span class="hljs-comment">// panic handler</span>

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> tm4c123x;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">init</span></span>() -&gt; (Delay, Leds) {
    <span class="hljs-keyword">let</span> cp = cortex_m::Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> p = tm4c123x::Peripherals::take().unwrap();

    <span class="hljs-keyword">let</span> pwm = p.PWM0;
    pwm.ctl.write(|w| w.globalsync0().clear_bit());
    <span class="hljs-comment">// Mode = 1 =&gt; Count up/down mode</span>
    pwm._2_ctl.write(|w| w.enable().set_bit().mode().set_bit());
    pwm._2_gena.write(|w| w.actcmpau().zero().actcmpad().one());
    <span class="hljs-comment">// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)</span>
    pwm._2_load.write(|w| <span class="hljs-keyword">unsafe</span> { w.load().bits(<span class="hljs-number">263</span>) });
    pwm._2_cmpa.write(|w| <span class="hljs-keyword">unsafe</span> { w.compa().bits(<span class="hljs-number">64</span>) });
    pwm.enable.write(|w| w.pwm4en().set_bit());
}

</code></pre>
<p>We've accessed the <code class="hljs">PWM0</code> peripheral in exactly the same way as we accessed the <code class="hljs">SYST</code> peripheral earlier, except we called <code class="hljs">tm4c123x::Peripherals::take()</code>. As this crate was auto-generated using <a href="https://crates.io/crates/svd2rust">svd2rust</a>, the access functions for our register fields take a closure, rather than a numeric argument. While this looks like a lot of code, the Rust compiler can use it to perform a bunch of checks for us, but then generate machine-code which is pretty close to hand-written assembler! Where the auto-generated code isn't able to determine that all possible arguments to a particular accessor function are valid (for example, if the SVD defines the register as 32-bit but doesn't say if some of those 32-bit values have a special meaning), then the function is marked as <code class="hljs">unsafe</code>. We can see this in the example above when setting the <code class="hljs">load</code> and <code class="hljs">compa</code> sub-fields using the <code class="hljs">bits()</code> function.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#reading" id="reading">Reading</a></h3>
<p>The <code class="hljs">read()</code> function returns an object which gives read-only access to the various sub-fields within this register, as defined by the manufacturer's SVD file for this chip. You can find all the functions available on special <code class="hljs">R</code> return type for this particular register, in this particular peripheral, on this particular chip, in the <a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html">tm4c123x documentation</a>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">if</span> pwm.ctl.read().globalsync0().is_set() {
    <span class="hljs-comment">// Do a thing</span>
}
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#writing" id="writing">Writing</a></h3>
<p>The <code class="hljs">write()</code> function takes a closure with a single argument. Typically we call this <code class="hljs">w</code>. This argument then gives read-write access to the various sub-fields within this register, as defined by the manufacturer's SVD file for this chip. Again, you can find all the functions available on the 'w' for this particular register, in this particular peripheral, on this particular chip, in the <a href="https://docs.rs/tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.W.html">tm4c123x documentation</a>. Note that all of the sub-fields that we do not set will be set to a default value for us - any existing content in the register will be lost.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs">pwm.ctl.write(|w| w.globalsync0().clear_bit());
</code></pre>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#modifying" id="modifying">Modifying</a></h3>
<p>If we wish to change only one particular sub-field in this register and leave the other sub-fields unchanged, we can use the <code class="hljs">modify</code> function. This function takes a closure with two arguments - one for reading and one for writing. Typically we call these <code class="hljs">r</code> and <code class="hljs">w</code> respectively. The <code class="hljs">r</code> argument can be used to inspect the current contents of the register, and the <code class="hljs">w</code> argument can be used to modify the register contents.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs">pwm.ctl.modify(|r, w| w.globalsync0().clear_bit());
</code></pre>
<p>The <code class="hljs">modify</code> function really shows the power of closures here. In C, we'd have to read into some temporary value, modify the correct bits and then write the value back. This means there's considerable scope for error:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C hljs"><span class="hljs-keyword">uint32_t</span> temp = pwm0.ctl.read();
temp |= PWM0_CTL_GLOBALSYNC0;
pwm0.ctl.write(temp);
<span class="hljs-keyword">uint32_t</span> temp2 = pwm0.enable.read();
temp2 |= PWM0_ENABLE_PWM4EN;
pwm0.enable.write(temp); <span class="hljs-comment">// Uh oh! Wrong variable!</span>
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#using-a-hal-crate" id="using-a-hal-crate">Using a HAL crate</a></h2>
<p>The HAL crate for a chip typically works by implementing a custom Trait for the raw structures exposed by the PAC. Often this trait will define a function called <code class="hljs">constrain()</code> for single peripherals or <code class="hljs">split()</code> for things like GPIO ports with multiple pins. This function will consume the underlying raw peripheral structure and return a new object with a higher-level API. This API may also do things like have the Serial port <code class="hljs">new</code> function require a borrow on some <code class="hljs">Clock</code> structure, which can only be generated by calling the function which configures the PLLs and sets up all the clock frequencies. In this way, it is statically impossible to create a Serial port object without first having configured the clock rates, or for the Serial port object to mis-convert the baud rate into clock ticks. Some crates even define special traits for the states each GPIO pin can be in, requiring the user to put a pin into the correct state (say, by selecting the appropriate Alternate Function Mode) before passing the pin into Peripheral. All with no run-time cost!</p>
<p>Let's see an example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_std]</span>
<span class="hljs-meta">#![no_main]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt; <span class="hljs-comment">// panic handler</span>

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> tm4c123x_hal <span class="hljs-keyword">as</span> hal;
<span class="hljs-keyword">use</span> tm4c123x_hal::prelude::*;
<span class="hljs-keyword">use</span> tm4c123x_hal::serial::{NewlineMode, Serial};
<span class="hljs-keyword">use</span> tm4c123x_hal::sysctl;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> p = hal::Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> cp = hal::CorePeripherals::take().unwrap();

    <span class="hljs-comment">// Wrap up the SYSCTL struct into an object with a higher-layer API</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> sc = p.SYSCTL.constrain();
    <span class="hljs-comment">// Pick our oscillation settings</span>
    sc.clock_setup.oscillator = sysctl::Oscillator::Main(
        sysctl::CrystalFrequency::_16mhz,
        sysctl::SystemClock::UsePll(sysctl::PllOutputFrequency::_80_00mhz),
    );
    <span class="hljs-comment">// Configure the PLL with those settings</span>
    <span class="hljs-keyword">let</span> clocks = sc.clock_setup.freeze();

    <span class="hljs-comment">// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.</span>
    <span class="hljs-comment">// Note it needs to borrow `sc.power_control` so it can power up the GPIO</span>
    <span class="hljs-comment">// peripheral automatically.</span>
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> porta = p.GPIO_PORTA.split(&amp;sc.power_control);

    <span class="hljs-comment">// Activate the UART.</span>
    <span class="hljs-keyword">let</span> uart = Serial::uart0(
        p.UART0,
        <span class="hljs-comment">// The transmit pin</span>
        porta
            .pa1
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;<span class="hljs-keyword">mut</span> porta.control),
        <span class="hljs-comment">// The receive pin</span>
        porta
            .pa0
            .into_af_push_pull::&lt;hal::gpio::AF1&gt;(&amp;<span class="hljs-keyword">mut</span> porta.control),
        <span class="hljs-comment">// No RTS or CTS required</span>
        (),
        (),
        <span class="hljs-comment">// The baud rate</span>
        <span class="hljs-number">115200_u32</span>.bps(),
        <span class="hljs-comment">// Output handling</span>
        NewlineMode::SwapLFtoCRLF,
        <span class="hljs-comment">// We need the clock rates to calculate the baud rate divisors</span>
        &amp;clocks,
        <span class="hljs-comment">// We need this to power up the UART peripheral</span>
        &amp;sc.power_control,
    );

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-built_in">writeln!</span>(uart, <span class="hljs-string">"Hello, World!\r\n"</span>).unwrap();
    }
}
</code></pre>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#semihosting" id="semihosting">Semihosting</a></h1>
<p>Semihosting is a mechanism that lets embedded devices do I/O on the host and is
mainly used to log messages to the host console. Semihosting requires a debug
session and pretty much nothing else (no extra wires!) so it's super convenient
to use. The downside is that it's super slow: each write operation can take
several milliseconds depending on the hardware debugger (e.g. ST-Link) you use.</p>
<p>The <a href="https://crates.io/crates/cortex-m-semihosting"><code class="hljs">cortex-m-semihosting</code></a> crate provides an API to do semihosting operations
on Cortex-M devices. The program below is the semihosting version of "Hello,
world!":</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> cortex_m_semihosting::hprintln;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    hprintln!(<span class="hljs-string">"Hello, world!"</span>).unwrap();

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>If you run this program on hardware you'll see the "Hello, world!" message
within the OpenOCD logs.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd</span>
(..)
Hello, world!
(..)
</code></pre>
<p>You do need to enable semihosting in OpenOCD from GDB first:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell">(gdb) monitor arm semihosting enable
semihosting is enabled
</code></pre>
<p>QEMU understands semihosting operations so the above program will also work with
<code class="hljs">qemu-system-arm</code> without having to start a debug session. Note that you'll
need to pass the <code class="hljs">-semihosting-config</code> flag to QEMU to enable semihosting
support; these flags are already included in the <code class="hljs">.cargo/config</code> file of the
template.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-comment"># this program will block the terminal</span></span>
<span class="hljs-meta">$</span><span class="bash"> cargo run</span>
     Running `qemu-system-arm (..)
Hello, world!
</code></pre>
<p>There's also an <code class="hljs">exit</code> semihosting operation that can be used to terminate the
QEMU process. Important: do <strong>not</strong> use <code class="hljs">debug::exit</code> on hardware; this function
can corrupt your OpenOCD session and you will not be able to debug more programs
until you restart it.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> cortex_m_semihosting::debug;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> roses = <span class="hljs-string">"blue"</span>;

    <span class="hljs-keyword">if</span> roses == <span class="hljs-string">"red"</span> {
        debug::exit(debug::EXIT_SUCCESS);
    } <span class="hljs-keyword">else</span> {
        debug::exit(debug::EXIT_FAILURE);
    }

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run</span>
     Running `qemu-system-arm (..)
<span class="hljs-meta">
$</span><span class="bash"> <span class="hljs-built_in">echo</span> $?</span>
1
</code></pre>
<p>One last tip: you can set the panicking behavior to <code class="hljs">exit(EXIT_FAILURE)</code>. This
will let you write <code class="hljs">no_std</code> run-pass tests that you can run on QEMU.</p>
<p>For convenience, the <code class="hljs">panic-semihosting</code> crate has an "exit" feature that when
enabled invokes <code class="hljs">exit(EXIT_FAILURE)</code> after logging the panic message to the host
stderr.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_semihosting; <span class="hljs-comment">// features = ["exit"]</span>

<span class="hljs-keyword">use</span> cortex_m_rt::entry;
<span class="hljs-keyword">use</span> cortex_m_semihosting::debug;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> roses = <span class="hljs-string">"blue"</span>;

    <span class="hljs-built_in">assert_eq!</span>(roses, <span class="hljs-string">"red"</span>);

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run</span>
     Running `qemu-system-arm (..)
panicked at 'assertion failed: `(left == right)`
  left: `"blue"`,
 right: `"red"`', examples/hello.rs:15:5
<span class="hljs-meta">
$</span><span class="bash"> <span class="hljs-built_in">echo</span> $?</span>
1
</code></pre>
<p><strong>NOTE</strong>: To enable this feature on <code class="hljs">panic-semihosting</code>, edit your
<code class="hljs">Cargo.toml</code> dependencies section where <code class="hljs">panic-semihosting</code> is specified with:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-attr">panic-semihosting</span> = { version = <span class="hljs-string">"VERSION"</span>, features = [<span class="hljs-string">"exit"</span>] }
</code></pre>
<p>where <code class="hljs">VERSION</code> is the version desired. For more information on dependencies
features check the <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html"><code class="hljs">specifying dependencies</code></a> section of the Cargo book.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#panicking" id="panicking">Panicking</a></h1>
<p>Panicking is a core part of the Rust language. Built-in operations like indexing
are runtime checked for memory safety. When out of bounds indexing is attempted
this results in a panic.</p>
<p>In the standard library panicking has a defined behavior: it unwinds the stack
of the panicking thread, unless the user opted for aborting the program on
panics.</p>
<p>In programs without standard library, however, the panicking behavior is left
undefined. A behavior can be chosen by declaring a <code class="hljs">#[panic_handler]</code> function.
This function must appear exactly <em>once</em> in the dependency graph of a program,
and must have the following signature: <code class="hljs">fn(&amp;PanicInfo) -&gt; !</code>, where <a href="https://doc.rust-lang.org/core/panic/struct.PanicInfo.html"><code class="hljs">PanicInfo</code></a>
is a struct containing information about the location of the panic.</p>
<p>Given that embedded systems range from user facing to safety critical (cannot
crash) there's no one size fits all panicking behavior but there are plenty of
commonly used behaviors. These common behaviors have been packaged into crates
that define the <code class="hljs">#[panic_handler]</code> function. Some examples include:</p>
<ul>
<li><a href="https://crates.io/crates/panic-abort"><code class="hljs">panic-abort</code></a>. A panic causes the abort instruction to be executed.</li>
<li><a href="https://crates.io/crates/panic-halt"><code class="hljs">panic-halt</code></a>. A panic causes the program, or the current thread, to halt by
entering an infinite loop.</li>
<li><a href="https://crates.io/crates/panic-itm"><code class="hljs">panic-itm</code></a>. The panicking message is logged using the ITM, an ARM Cortex-M
specific peripheral.</li>
<li><a href="https://crates.io/crates/panic-semihosting"><code class="hljs">panic-semihosting</code></a>. The panicking message is logged to the host using the
semihosting technique.</li>
</ul>
<p>You may be able to find even more crates searching for the <a href="https://crates.io/keywords/panic-handler"><code class="hljs">panic-handler</code></a>
keyword on crates.io.</p>
<p>A program can pick one of these behaviors simply by linking to the corresponding
crate. The fact that the panicking behavior is expressed in the source of
an application as a single line of code is not only useful as documentation but
can also be used to change the panicking behavior according to the compilation
profile. For example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-comment">// dev profile: easier to debug panics; can put a breakpoint on `rust_begin_unwind`</span>
<span class="hljs-meta">#[cfg(debug_assertions)]</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-comment">// release profile: minimize the binary size of the application</span>
<span class="hljs-meta">#[cfg(not(debug_assertions))]</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_abort;

<span class="hljs-comment">// ..</span>
</code></pre>
<p>In this example the crate links to the <code class="hljs">panic-halt</code> crate when built with the
dev profile (<code class="hljs">cargo build</code>), but links to the <code class="hljs">panic-abort</code> crate when built
with the release profile (<code class="hljs">cargo build --release</code>).</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#an-example" id="an-example">An example</a></h2>
<p>Here's an example that tries to index an array beyond its length. The operation
results in a panic.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_semihosting;

<span class="hljs-keyword">use</span> cortex_m_rt::entry;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> xs = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
    <span class="hljs-keyword">let</span> i = xs.len() + <span class="hljs-number">1</span>;
    <span class="hljs-keyword">let</span> _y = xs[i]; <span class="hljs-comment">// out of bounds access</span>

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>This example chose the <code class="hljs">panic-semihosting</code> behavior which prints the panic
message to the host console using semihosting.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run</span>
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
panicked at 'index out of bounds: the len is 3 but the index is 4', src/main.rs:12:13
</code></pre>
<p>You can try changing the behavior to <code class="hljs">panic-halt</code> and confirm that no message is
printed in that case.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#exceptions" id="exceptions">Exceptions</a></h1>
<p>Exceptions, and interrupts, are a hardware mechanism by which the processor
handles asynchronous events and fatal errors (e.g. executing an invalid
instruction). Exceptions imply preemption and involve exception handlers,
subroutines executed in response to the signal that triggered the event.</p>
<p>The <code class="hljs">cortex-m-rt</code> crate provides an <a href="https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.exception.html"><code class="hljs">exception</code></a> attribute to declare exception
handlers.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">// Exception handler for the SysTick (System Timer) exception</span>
<span class="hljs-meta">#[exception]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">SysTick</span></span>() {
    <span class="hljs-comment">// ..</span>
}
</code></pre>
<p>Other than the <code class="hljs">exception</code> attribute exception handlers look like plain
functions but there's one more difference: <code class="hljs">exception</code> handlers can <em>not</em> be
called by software. Following the previous example, the statement <code class="hljs">SysTick();</code>
would result in a compilation error.</p>
<p>This behavior is pretty much intended and it's required to provide a feature:
<code class="hljs">static mut</code> variables declared <em>inside</em> <code class="hljs">exception</code> handlers are <em>safe</em> to use.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[exception]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">SysTick</span></span>() {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNT: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// `COUNT` has type `&amp;mut u32` and it's safe to use</span>
    *COUNT += <span class="hljs-number">1</span>;
}
</code></pre>
<p>As you may know, using <code class="hljs">static mut</code> variables in a function makes it
<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)"><em>non-reentrant</em></a>. It's undefined behavior to call a non-reentrant function,
directly or indirectly, from more than one exception / interrupt handler or from
<code class="hljs">main</code> and one or more exception / interrupt handlers.</p>
<p>Safe Rust must never result in undefined behavior so non-reentrant functions
must be marked as <code class="hljs">unsafe</code>. Yet I just told that <code class="hljs">exception</code> handlers can safely
use <code class="hljs">static mut</code> variables. How is this possible? This is possible because
<code class="hljs">exception</code> handlers can <em>not</em> be called by software thus reentrancy is not
possible.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#a-complete-example" id="a-complete-example">A complete example</a></h2>
<p>Here's an example that uses the system timer to raise a <code class="hljs">SysTick</code> exception
roughly every second. The <code class="hljs">SysTick</code> exception handler keeps track of how many
times it has been called in the <code class="hljs">COUNT</code> variable and then prints the value of
<code class="hljs">COUNT</code> to the host console using semihosting.</p>
<blockquote>
<p><strong>NOTE</strong>: You can run this example on any Cortex-M device; you can also run it
on QEMU</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![deny(unsafe_code)]</span>
<span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> core::fmt::Write;

<span class="hljs-keyword">use</span> cortex_m::peripheral::syst::SystClkSource;
<span class="hljs-keyword">use</span> cortex_m_rt::{entry, exception};
<span class="hljs-keyword">use</span> cortex_m_semihosting::{
    debug,
    hio::{<span class="hljs-keyword">self</span>, HStdout},
};

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> p = cortex_m::Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> syst = p.SYST;

    <span class="hljs-comment">// configures the system timer to trigger a SysTick exception every second</span>
    syst.set_clock_source(SystClkSource::Core);
    <span class="hljs-comment">// this is configured for the LM3S6965 which has a default CPU clock of 12 MHz</span>
    syst.set_reload(<span class="hljs-number">12_000_000</span>);
    syst.clear_current();
    syst.enable_counter();
    syst.enable_interrupt();

    <span class="hljs-keyword">loop</span> {}
}

<span class="hljs-meta">#[exception]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">SysTick</span></span>() {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNT: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> STDOUT: <span class="hljs-built_in">Option</span>&lt;HStdout&gt; = <span class="hljs-literal">None</span>;

    *COUNT += <span class="hljs-number">1</span>;

    <span class="hljs-comment">// Lazy initialization</span>
    <span class="hljs-keyword">if</span> STDOUT.is_none() {
        *STDOUT = hio::hstdout().ok();
    }

    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(hstdout) = STDOUT.as_mut() {
        <span class="hljs-built_in">write!</span>(hstdout, <span class="hljs-string">"{}"</span>, *COUNT).ok();
    }

    <span class="hljs-comment">// IMPORTANT omit this `if` block if running on real hardware or your</span>
    <span class="hljs-comment">// debugger will end in an inconsistent state</span>
    <span class="hljs-keyword">if</span> *COUNT == <span class="hljs-number">9</span> {
        <span class="hljs-comment">// This will terminate the QEMU process</span>
        debug::exit(debug::EXIT_SUCCESS);
    }
}
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> tail -n5 Cargo.toml</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[dependencies]</span>
<span class="hljs-attr">cortex-m</span> = <span class="hljs-string">"0.5.7"</span>
<span class="hljs-attr">cortex-m-rt</span> = <span class="hljs-string">"0.6.3"</span>
<span class="hljs-attr">panic-halt</span> = <span class="hljs-string">"0.2.0"</span>
<span class="hljs-attr">cortex-m-semihosting</span> = <span class="hljs-string">"0.3.1"</span>
</code></pre>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo run --release</span>
     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb (..)
123456789
</code></pre>
<p>If you run this on the Discovery board you'll see the output on the OpenOCD
console. Also, the program will <em>not</em> stop when the count reaches 9.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-default-exception-handler" id="the-default-exception-handler">The default exception handler</a></h2>
<p>What the <code class="hljs">exception</code> attribute actually does is <em>override</em> the default exception
handler for a specific exception. If you don't override the handler for a
particular exception it will be handled by the <code class="hljs">DefaultHandler</code> function, which
defaults to:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">DefaultHandler</span></span>() {
    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>This function is provided by the <code class="hljs">cortex-m-rt</code> crate and marked as
<code class="hljs">#[no_mangle]</code> so you can put a breakpoint on "DefaultHandler" and catch
<em>unhandled</em> exceptions.</p>
<p>It's possible to override this <code class="hljs">DefaultHandler</code> using the <code class="hljs">exception</code> attribute:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[exception]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">DefaultHandler</span></span>(irqn: <span class="hljs-built_in">i16</span>) {
    <span class="hljs-comment">// custom default handler</span>
}
</code></pre>
<p>The <code class="hljs">irqn</code> argument indicates which exception is being serviced. A negative
value indicates that a Cortex-M exception is being serviced; and zero or a
positive value indicate that a device specific exception, AKA interrupt, is
being serviced.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-hard-fault-handler" id="the-hard-fault-handler">The hard fault handler</a></h2>
<p>The <code class="hljs">HardFault</code> exception is a bit special. This exception is fired when the
program enters an invalid state so its handler can <em>not</em> return as that could
result in undefined behavior. Also, the runtime crate does a bit of work before
the user defined <code class="hljs">HardFault</code> handler is invoked to improve debuggability.</p>
<p>The result is that the <code class="hljs">HardFault</code> handler must have the following signature:
<code class="hljs">fn(&amp;ExceptionFrame) -&gt; !</code>. The argument of the handler is a pointer to
registers that were pushed into the stack by the exception. These registers are
a snapshot of the processor state at the moment the exception was triggered and
are useful to diagnose a hard fault.</p>
<p>Here's an example that performs an illegal operation: a read to a nonexistent
memory location.</p>
<blockquote>
<p><strong>NOTE</strong>: This program won't work, i.e. it won't crash, on QEMU because
<code class="hljs">qemu-system-arm -machine lm3s6965evb</code> doesn't check memory loads and will
happily return <code class="hljs">0 </code>on reads to invalid memory.</p>
</blockquote>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![no_main]</span>
<span class="hljs-meta">#![no_std]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> panic_halt;

<span class="hljs-keyword">use</span> core::fmt::Write;
<span class="hljs-keyword">use</span> core::ptr;

<span class="hljs-keyword">use</span> cortex_m_rt::{entry, exception, ExceptionFrame};
<span class="hljs-keyword">use</span> cortex_m_semihosting::hio;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-comment">// read a nonexistent memory location</span>
    <span class="hljs-keyword">unsafe</span> {
        ptr::read_volatile(<span class="hljs-number">0x3FFF_FFFE</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">const</span> <span class="hljs-built_in">u32</span>);
    }

    <span class="hljs-keyword">loop</span> {}
}

<span class="hljs-meta">#[exception]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">HardFault</span></span>(ef: &amp;ExceptionFrame) -&gt; ! {
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">mut</span> hstdout) = hio::hstdout() {
        <span class="hljs-built_in">writeln!</span>(hstdout, <span class="hljs-string">"{:#?}"</span>, ef).ok();
    }

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>The <code class="hljs">HardFault</code> handler prints the <code class="hljs">ExceptionFrame</code> value. If you run this
you'll see something like this on the OpenOCD console.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> openocd</span>
(..)
ExceptionFrame {
    r0: 0x3ffffffe,
    r1: 0x00f00000,
    r2: 0x20000000,
    r3: 0x00000000,
    r12: 0x00000000,
    lr: 0x080008f7,
    pc: 0x0800094a,
    xpsr: 0x61000000
}
</code></pre>
<p>The <code class="hljs">pc</code> value is the value of the Program Counter at the time of the exception
and it points to the instruction that triggered the exception.</p>
<p>If you look at the disassembly of the program:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo objdump --bin app --release -- -d -no-show-raw-insn -<span class="hljs-built_in">print</span>-imm-hex</span>
(..)
ResetTrampoline:
 8000942:       movw    r0, #0xfffe
 8000946:       movt    r0, #0x3fff
 800094a:       ldr     r0, [r0]
 800094c:       b       #-0x4 &lt;ResetTrampoline+0xa&gt;
</code></pre>
<p>You can lookup the value of the program counter <code class="hljs">0x0800094a</code> in the dissassembly.
You'll see that a load operation (<code class="hljs">ldr r0, [r0]</code> ) caused the exception.
The <code class="hljs">r0</code> field of <code class="hljs">ExceptionFrame</code> will tell you the value of register <code class="hljs">r0</code>
was <code class="hljs">0x3fff_fffe</code> at that time.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#interrupts" id="interrupts">Interrupts</a></h1>
<p>Interrupts differ from exceptions in a variety of ways but their operation and
use is largely similar and they are also handled by the same interrupt
controller. Whereas exceptions are defined by the Cortex-M architecture,
interrupts are always vendor (and often even chip) specific implementations,
both in naming and functionality.</p>
<p>Interrupts do allow for a lot of flexibility which needs to be accounted for
when attempting to use them in an advanced way. We will not cover those uses in
this book, however it is a good idea to keep the following in mind:</p>
<ul>
<li>Interrupts have programmable priorities which determine their handlers' execution order</li>
<li>Interrupts can nest and preempt, i.e. execution of an interrupt handler might be interrupted by another higher-priority interrupt</li>
<li>In general the reason causing the interrupt to trigger needs to be cleared to prevent re-entering the interrupt handler endlessly</li>
</ul>
<p>The general initialization steps at runtime are always the same:</p>
<ul>
<li>Setup the peripheral(s) to generate interrupts requests at the desired occasions</li>
<li>Set the desired priority of the interrupt handler in the interrupt controller</li>
<li>Enable the interrupt handler in the interrupt controller</li>
</ul>
<p>Similarly to exceptions, the <code class="hljs">cortex-m-rt</code> crate provides an <a href="https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/attr.interrupt.html"><code class="hljs">interrupt</code></a>
attribute to declare interrupt handlers. The available interrupts (and
their position in the interrupt handler table) are usually automatically
generated via <code class="hljs">svd2rust</code> from a SVD description.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">// Interrupt handler for the Timer2 interrupt</span>
<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">TIM2</span></span>() {
    <span class="hljs-comment">// ..</span>
    <span class="hljs-comment">// Clear reason for the generated interrupt request</span>
}
</code></pre>
<p>Interrupt handlers look like plain functions (except for the lack of arguments)
similar to exception handlers. However they can not be called directly by other
parts of the firmware due to the special calling conventions. It is however
possible to generate interrupt requests in software to trigger a diversion to
to the interrupt handler.</p>
<p>Similar to exception handlers it is also possible to declare <code class="hljs">static mut</code>
variables inside the interrupt handlers for <em>safe</em> state keeping.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">TIM2</span></span>() {
    <span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNT: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;

    <span class="hljs-comment">// `COUNT` has type `&amp;mut u32` and it's safe to use</span>
    *COUNT += <span class="hljs-number">1</span>;
}
</code></pre>
<p>For a more detailed description about the mechanisms demonstrated here please
refer to the <a href="https://rust-embedded.github.io/book/start/exceptions.html">exceptions section</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#io" id="io">IO</a></h1>
<blockquote>
<p><strong>TODO</strong> Cover memory mapped I/O using registers.</p>
</blockquote>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#peripherals" id="peripherals">Peripherals</a></h1>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#what-are-peripherals" id="what-are-peripherals">What are Peripherals?</a></h2>
<p>Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they contain sections of silicon which are used for interacting with systems outside of the microcontroller, as well as directly and indirectly interacting with their surroundings in the world via sensors, motor controllers, or human interfaces such as a display or keyboard. These components are collectively known as Peripherals.</p>
<p>These peripherals are useful because they allow a developer to offload processing to them, avoiding having to handle everything in software. Similar to how a desktop developer would offload graphics processing to a video card, embedded developers can offload some tasks to peripherals allowing the CPU to spend its time doing something else important, or doing nothing in order to save power.</p>
<p>If you look at the main circuit board in an old-fashioned home computer from the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so far removed from the embedded systems of today) you would expect to see:</p>
<ul>
<li>A processor</li>
<li>A RAM chip</li>
<li>A ROM chip</li>
<li>An I/O controller</li>
</ul>
<p>The RAM chip, ROM chip and I/O controller (the peripheral in this system) would be joined to the processor through a series of parallel traces known as a 'bus'. This bus carries address information, which selects which device on the bus the processor wishes to communicate with, and a data bus which carries the actual data. In our embedded microcontrollers, the same principles apply - it's just that everything is packed on to a single piece of silicon.</p>
<p>However, unlike graphics cards, which typically have a Software API like Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller with a hardware interface, which is mapped to a chunk of the memory.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#linear-and-real-memory-space" id="linear-and-real-memory-space">Linear and Real Memory Space</a></h2>
<p>On a microcontroller, writing some data to some other arbitrary address, such as <code class="hljs">0x4000_0000</code> or <code class="hljs">0x0000_0000</code>, may also be a completely valid action.</p>
<p>On a desktop system, access to memory is tightly controlled by the MMU, or Memory Management Unit. This component has two major responsibilities: enforcing access permission to sections of memory (preventing one process from reading or modifying the memory of another process); and re-mapping segments of the physical memory to virtual memory ranges used in software. Microcontrollers do not typically have an MMU, and instead only use real physical addresses in software.</p>
<p>Although 32 bit microcontrollers have a real and linear address space from <code class="hljs">0x0000_0000</code>, and <code class="hljs">0xFFFF_FFFF</code>, they generally only use a few hundred kilobytes of that range for actual memory. This leaves a significant amount of address space remaining. In earlier chapters, we were talking about RAM being located at address <code class="hljs">0x2000_0000</code>. If our RAM was 64 KiB long (i.e. with a maximum address of 0xFFFF) then addresses <code class="hljs">0x2000_0000</code> to <code class="hljs">0x2000_FFFF</code> would correspond to our RAM. When we write to a variable which lives at address <code class="hljs">0x2000_1234</code>, what happens internally is that some logic detects the upper portion of the address (0x2000 in this example) and then activates the RAM so that it can act upon the lower portion of the address (0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at address <code class="hljs">0x0000_0000</code> up to, say, address <code class="hljs">0x0007_FFFF</code> (if we have a 512 KiB Flash ROM). Rather than ignore all remaining space between these two regions, Microcontroller designers instead mapped the interface for peripherals in certain memory locations. This ends up looking something like this:</p>
<p><img src="./The Embedded Rust Book_files/nrf52-memory-map.png" alt=""></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 Datasheet (pdf)</a></p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#memory-mapped-peripherals" id="memory-mapped-peripherals">Memory Mapped Peripherals</a></h2>
<p>Interaction with these peripherals is simple at a first glance - write the right data to the correct address. For example, sending a 32 bit word over a serial port could be as direct as writing that 32 bit word to a certain memory address. The Serial Port Peripheral would then take over and send out the data automatically.</p>
<p>Configuration of these peripherals works similarly. Instead of calling a function to configure a peripheral, a chunk of memory is exposed which serves as the hardware API. Write <code class="hljs">0x8000_0000</code> to a SPI Frequency Configuration Register, and the SPI port will send data at 8 Megabits per second. Write <code class="hljs">0x0200_0000</code> to the same address, and the SPI port will send data at 125 Kilobits per second. These configuration registers look a little bit like this:</p>
<p><img src="./The Embedded Rust Book_files/nrf52-spi-frequency-register.png" alt=""></p>
<p><a href="http://infocenter.nordicsemi.com/pdf/nRF52832_PS_v1.1.pdf">Nordic nRF52832 Datasheet (pdf)</a></p>
<p>This interface is how interactions with the hardware are made, no matter what language is used, whether that language is Assembly, C, or Rust.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#a-first-attempt" id="a-first-attempt">A First Attempt</a></h1>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-registers" id="the-registers">The Registers</a></h2>
<p>Let's look at the 'SysTick' peripheral - a simple timer which comes with every Cortex-M processor core. Typically you'll be looking these up in the chip manufacturer's data sheet or <em>Technical Reference Manual</em>, but this example is common to all ARM Cortex-M cores, let's look in the <a href="http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/Babieigh.html">ARM reference manual</a>. We see there are four registers:</p>
<table><thead><tr><th>Offset</th><th>Name</th><th>Description</th><th>Width</th></tr></thead><tbody>
<tr><td>0x00</td><td>SYST_CSR</td><td>Control and Status Register</td><td>32 bits</td></tr>
<tr><td>0x04</td><td>SYST_RVR</td><td>Reload Value Register</td><td>32 bits</td></tr>
<tr><td>0x08</td><td>SYST_CVR</td><td>Current Value Register</td><td>32 bits</td></tr>
<tr><td>0x0C</td><td>SYST_CALIB</td><td>Calibration Value Register</td><td>32 bits</td></tr>
</tbody></table>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-c-approach" id="the-c-approach">The C Approach</a></h2>
<p>In Rust, we can represent a collection of registers in exactly the same way as we do in C - with a <code class="hljs">struct</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SysTick</span></span> {
    <span class="hljs-keyword">pub</span> csr: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span> rvr: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span> cvr: <span class="hljs-built_in">u32</span>,
    <span class="hljs-keyword">pub</span> calib: <span class="hljs-built_in">u32</span>,
}
</code></pre>
<p>The qualifier <code class="hljs">#[repr(C)]</code> tells the Rust compiler to lay this structure out like a C compiler would. That's very important, as Rust allows structure fields to be re-ordered, while C does not. You can imagine the debugging we'd have to do if these fields were silently re-arranged by the compiler! With this qualifier in place, we have our four 32-bit fields which correspond to the table above. But of course, this <code class="hljs">struct</code> is of no use by itself - we need a variable.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">let</span> systick = <span class="hljs-number">0xE000_E010</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> SysTick;
<span class="hljs-keyword">let</span> time = <span class="hljs-keyword">unsafe</span> { (*systick).cvr };
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#volatile-accesses" id="volatile-accesses">Volatile Accesses</a></h2>
<p>Now, there are a couple of problems with the approach above.</p>
<ol>
<li>We have to use unsafe every time we want to access our Peripheral.</li>
<li>We've got no way of specifying which registers are read-only or read-write.</li>
<li>Any piece of code anywhere in your program could access the hardware
through this structure.</li>
<li>Most importantly, it doesn't actually work...</li>
</ol>
<p>Now, the problem is that compilers are clever. If you make two writes to the same piece of RAM, one after the other, the compiler can notice this and just skip the first write entirely. In C, we can mark variables as <code class="hljs">volatile</code> to ensure that every read or write occurs as intended. In Rust, we instead mark the <em>accesses</em> as volatile, not the variable.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">let</span> systick = <span class="hljs-keyword">unsafe</span> { &amp;<span class="hljs-keyword">mut</span> *(<span class="hljs-number">0xE000_E010</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> SysTick) };
<span class="hljs-keyword">let</span> time = <span class="hljs-keyword">unsafe</span> { core::ptr::read_volatile(&amp;<span class="hljs-keyword">mut</span> systick.cvr) };
</code></pre>
<p>So, we've fixed one of our four problems, but now we have even more <code class="hljs">unsafe</code> code! Fortunately, there's a third party crate which can help - <a href="https://crates.io/crates/volatile_register"><code class="hljs">volatile_register</code></a>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> volatile_register::{RW, RO};

<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SysTick</span></span> {
    <span class="hljs-keyword">pub</span> csr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> rvr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> cvr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> calib: RO&lt;<span class="hljs-built_in">u32</span>&gt;,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_systick</span></span>() -&gt; &amp;<span class="hljs-symbol">'static</span> <span class="hljs-keyword">mut</span> SysTick {
    <span class="hljs-keyword">unsafe</span> { &amp;<span class="hljs-keyword">mut</span> *(<span class="hljs-number">0xE000_E010</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> SysTick) }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_time</span></span>() -&gt; <span class="hljs-built_in">u32</span> {
    <span class="hljs-keyword">let</span> systick = get_systick();
    systick.cvr.read()
}
</code></pre>
<p>Now, the volatile accesses are performed automatically through the <code class="hljs">read</code> and <code class="hljs">write</code> methods. It's still <code class="hljs">unsafe</code> to perform writes, but to be fair, hardware is a bunch of mutable state and there's no way for the compiler to know whether these writes are actually safe, so this is a good default position.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-rusty-wrapper" id="the-rusty-wrapper">The Rusty Wrapper</a></h2>
<p>We need to wrap this <code class="hljs">struct</code> up into a higher-layer API that is safe for our users to call. As the driver author, we manually verify the unsafe code is correct, and then present a safe API for our users so they don't have to worry about it (provided they trust us to get it right!).</p>
<p>One example might be:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> volatile_register::{RW, RO};

<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">SystemTimer</span></span> {
    p: &amp;<span class="hljs-symbol">'static</span> <span class="hljs-keyword">mut</span> RegisterBlock
}

<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">RegisterBlock</span></span> {
    <span class="hljs-keyword">pub</span> csr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> rvr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> cvr: RW&lt;<span class="hljs-built_in">u32</span>&gt;,
    <span class="hljs-keyword">pub</span> calib: RO&lt;<span class="hljs-built_in">u32</span>&gt;,
}

<span class="hljs-keyword">impl</span> SystemTimer {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>() -&gt; SystemTimer {
        SystemTimer {
            p: <span class="hljs-keyword">unsafe</span> { &amp;<span class="hljs-keyword">mut</span> *(<span class="hljs-number">0xE000_E010</span> <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> RegisterBlock) }
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_time</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">u32</span> {
        <span class="hljs-keyword">self</span>.p.cvr.read()
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_reload</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, reload_value: <span class="hljs-built_in">u32</span>) {
        <span class="hljs-keyword">unsafe</span> { <span class="hljs-keyword">self</span>.p.rvr.write(reload_value) }
    }
}

<span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">example_usage</span></span>() -&gt; <span class="hljs-built_in">String</span> {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> st = SystemTimer::new();
    st.set_reload(<span class="hljs-number">0x00FF_FFFF</span>);
    <span class="hljs-built_in">format!</span>(<span class="hljs-string">"Time is now 0x{:08x}"</span>, st.get_time())
}
</code></pre>
<p>Now, the problem with this approach is that the following code is perfectly acceptable to the compiler:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">thread1</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> st = SystemTimer::new();
    st.set_reload(<span class="hljs-number">2000</span>);
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">thread2</span></span>() {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> st = SystemTimer::new();
    st.set_reload(<span class="hljs-number">1000</span>);
}
</code></pre>
<p>Our <code class="hljs">&amp;mut self</code> argument to the <code class="hljs">set_reload</code> function checks that there are no other references to <em>that</em> particular <code class="hljs">SystemTimer</code> struct, but they don't stop the user creating a second <code class="hljs">SystemTimer</code> which points to the exact same peripheral! Code written in this fashion will work if the author is diligent enough to spot all of these 'duplicate' driver instances, but once the code is spread out over multiple modules, drivers, developers, and days, it gets easier and easier to make these kinds of mistakes.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#mutable-global-state" id="mutable-global-state">Mutable Global State</a></h2>
<p>Unfortunately, hardware is basically nothing but mutable global state, which can feel very frightening for a Rust developer. Hardware exists independently from the structures of the code we write, and can be modified at any time by the real world.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#what-should-our-rules-be" id="what-should-our-rules-be">What should our rules be?</a></h2>
<p>How can we reliably interact with these peripherals?</p>
<ol>
<li>Always use <code class="hljs">volatile</code> methods to read or write to peripheral memory, as it can change at any time</li>
<li>In software, we should be able to share any number of read-only accesses to these peripherals</li>
<li>If some software should have read-write access to a peripheral, it should hold the only reference to that peripheral</li>
</ol>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#the-borrow-checker" id="the-borrow-checker">The Borrow Checker</a></h2>
<p>The last two of these rules sound suspiciously similar to what the Borrow Checker does already!</p>
<p>Imagine if we could pass around ownership of these peripherals, or offer immutable or mutable references to them?</p>
<p>Well, we can, but for the Borrow Checker, we need to have exactly one instance of each peripheral, so Rust can handle this correctly. Well, luckliy in the hardware, there is only one instance of any given peripheral, but how can we expose that in the structure of our code?</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#singletons" id="singletons">Singletons</a></h1>
<blockquote>
<p>In software engineering, the singleton pattern is a software design pattern that restricts the instantiation of a class to one object.</p>
<p><em>Wikipedia: <a href="https://en.wikipedia.org/wiki/Singleton_pattern">Singleton Pattern</a></em></p>
</blockquote>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#but-why-cant-we-just-use-global-variables" id="but-why-cant-we-just-use-global-variables">But why can't we just use global variable(s)?</a></h2>
<p>We could make everything a public static, like this</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> THE_SERIAL_PORT: SerialPort = SerialPort;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> _ = <span class="hljs-keyword">unsafe</span> {
        THE_SERIAL_PORT.read_speed();
    };
}
</code></pre>
<p>But this has a few problems. It is a mutable global variable, and in Rust, these are always unsafe to interact with. These variables are also visible across your whole program, which means the borrow checker is unable to help you track references and ownership of these variables.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#how-do-we-do-this-in-rust" id="how-do-we-do-this-in-rust">How do we do this in Rust?</a></h2>
<p>Instead of just making our peripheral a global variable, we might instead decide to make a global variable, in this case called <code class="hljs">PERIPHERALS</code>, which contains an <code class="hljs">Option&lt;T&gt;</code> for each of our peripherals.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Peripherals</span></span> {
    serial: <span class="hljs-built_in">Option</span>&lt;SerialPort&gt;,
}
<span class="hljs-keyword">impl</span> Peripherals {
    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">take_serial</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) -&gt; SerialPort {
        <span class="hljs-keyword">let</span> p = replace(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.serial, <span class="hljs-literal">None</span>);
        p.unwrap()
    }
}
<span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> PERIPHERALS: Peripherals = Peripherals {
    serial: <span class="hljs-literal">Some</span>(SerialPort),
};
</code></pre>
<p>This structure allows us to obtain a single instance of our peripheral. If we try to call <code class="hljs">take_serial()</code> more than once, our code will panic!</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> serial_1 = <span class="hljs-keyword">unsafe</span> { PERIPHERALS.take_serial() };
    <span class="hljs-comment">// This panics!</span>
    <span class="hljs-comment">// let serial_2 = unsafe { PERIPHERALS.take_serial() };</span>
}
</code></pre>
<p>Although interacting with this structure is <code class="hljs">unsafe</code>, once we have the <code class="hljs">SerialPort</code> it contained, we no longer need to use <code class="hljs">unsafe</code>, or the <code class="hljs">PERIPHERALS</code> structure at all.</p>
<p>This has a small runtime overhead because we must wrap the <code class="hljs">SerialPort</code> structure in an option, and we'll need to call <code class="hljs">take_serial()</code> once, however this small up-front cost allows us to leverage the borrow checker throughout the rest of our program.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#existing-library-support" id="existing-library-support">Existing library support</a></h2>
<p>Although we created our own <code class="hljs">Peripherals</code> structure above, it is not necessary to do this for your code. the <code class="hljs">cortex_m</code> crate contains a macro called <code class="hljs">singleton!()</code> that will perform this action for you.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[macro_use(singleton)]</span>
<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> cortex_m;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// OK if `main` is executed only once</span>
    <span class="hljs-keyword">let</span> x: &amp;<span class="hljs-symbol">'static</span> <span class="hljs-keyword">mut</span> <span class="hljs-built_in">bool</span> =
        singleton!(: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>).unwrap();
}
</code></pre>
<p><a href="https://docs.rs/cortex-m/latest/cortex_m/macro.singleton.html">cortex_m docs</a></p>
<p>Additionally, if you use <code class="hljs">cortex-m-rtfm</code>, the entire process of defining and obtaining these peripherals are abstracted for you, and you are instead handed a <code class="hljs">Peripherals</code> structure that contains a non-<code class="hljs">Option&lt;T&gt;</code> version of all of the items you define.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">// cortex-m-rtfm v0.3.x</span>
app! {
    resources: {
        <span class="hljs-keyword">static</span> RX: Rx&lt;USART1&gt;;
        <span class="hljs-keyword">static</span> TX: Tx&lt;USART1&gt;;
    }
}
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">init</span></span>(p: init::Peripherals) -&gt; init::LateResources {
    <span class="hljs-comment">// Note that this is now an owned value, not a reference</span>
    <span class="hljs-keyword">let</span> usart1: USART1 = p.device.USART1;
}
</code></pre>
<p><a href="https://blog.japaric.io/rtfm-v3/">japaric.io rtfm v3</a></p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#but-why" id="but-why">But why?</a></h2>
<p>But how do these Singletons make a noticeable difference in how our Rust code works?</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">impl</span> SerialPort {
    <span class="hljs-keyword">const</span> SER_PORT_SPEED_REG: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u32</span> = <span class="hljs-number">0x4000_1000</span> <span class="hljs-keyword">as</span> _;

    <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_speed</span></span>(
        &amp;<span class="hljs-keyword">self</span> <span class="hljs-comment">// &lt;------ This is really, really important</span>
    ) -&gt; <span class="hljs-built_in">u32</span> {
        <span class="hljs-keyword">unsafe</span> {
            ptr::read_volatile(Self::SER_PORT_SPEED_REG)
        }
    }
}
</code></pre>
<p>There are two important factors in play here:</p>
<ul>
<li>Because we are using a singleton, there is only one way or place to obtain a <code class="hljs">SerialPort</code> structure</li>
<li>To call the <code class="hljs">read_speed()</code> method, we must have ownership or a reference to a <code class="hljs">SerialPort</code> structure</li>
</ul>
<p>These two factors put together means that it is only possible to access the hardware if we have appropriately satisfied the borrow checker, meaning that at no point do we have multiple mutable references to the same hardware!</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-comment">// missing reference to `self`! Won't work.</span>
    <span class="hljs-comment">// SerialPort::read_speed();</span>

    <span class="hljs-keyword">let</span> serial_1 = <span class="hljs-keyword">unsafe</span> { PERIPHERALS.take_serial() };

    <span class="hljs-comment">// you can only read what you have access to</span>
    <span class="hljs-keyword">let</span> _ = serial_1.read_speed();
}
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#treat-your-hardware-like-data" id="treat-your-hardware-like-data">Treat your hardware like data</a></h2>
<p>Additionally, because some references are mutable, and some are immutable, it becomes possible to see whether a function or method could potentially modify the state of the hardware. For example,</p>
<p>This is allowed to change hardware settings:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">setup_spi_port</span></span>(
    spi: &amp;<span class="hljs-keyword">mut</span> SpiPort,
    cs_pin: &amp;<span class="hljs-keyword">mut</span> GpioPin
) -&gt; <span class="hljs-built_in">Result</span>&lt;()&gt; {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>This isn't:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">read_button</span></span>(gpio: &amp;GpioPin) -&gt; <span class="hljs-built_in">bool</span> {
    <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>This allows us to enforce whether code should or should not make changes to hardware at <strong>compile time</strong>, rather than at runtime. As a note, this generally only works across one application, but for bare metal systems, our software will be compiled into a single application, so this is not usually a restriction.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#static-guarantees" id="static-guarantees">Static Guarantees</a></h1>
<p>Rust's type system prevents data races at compile time (see <a href="https://doc.rust-lang.org/core/marker/trait.Send.html"><code class="hljs">Send</code></a> and
<a href="https://doc.rust-lang.org/core/marker/trait.Sync.html"><code class="hljs">Sync</code></a> traits). The type system can also be used to check other properties at
compile time; reducing the need for runtime checks in some cases.</p>
<p>When applied to embedded programs these <em>static checks</em> can be used, for
example, to enforce that configuration of I/O interfaces is done properly. For
instance, one can design an API where it is only possible to initialize a serial
interface by first configuring the pins that will be used by the interface.</p>
<p>One can also statically check that operations, like setting a pin low, can only
be performed on correctly configured peripherals. For example, trying to change
the output state of a pin configured in floating input mode would raise a
compile error.</p>
<p>And, as seen in the previous chapter, the concept of ownership can be applied
to peripherals to ensure that only certain parts of a program can modify a
peripheral. This <em>access control</em> makes software easier to reason about
compared to the alternative of treating peripherals as global mutable state.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#typestate-programming" id="typestate-programming">Typestate Programming</a></h1>
<p>The concept of <a href="https://en.wikipedia.org/wiki/Typestate_analysis">typestates</a> describes the encoding of information about the current state of an object into the type of that object. Although this can sound a little arcane, if you have used the <a href="https://doc.rust-lang.org/1.0.0/style/ownership/builders.html">Builder Pattern</a> in Rust, you have already started using Typestate Programming!</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring"><span class="boring">[derive(<span class="hljs-built_in">Debug</span>)]
</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    inner: <span class="hljs-built_in">u32</span>,
}

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">FooBuilder</span></span> {
    a: <span class="hljs-built_in">u32</span>,
    b: <span class="hljs-built_in">u32</span>,
}

<span class="hljs-keyword">impl</span> FooBuilder {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(starter: <span class="hljs-built_in">u32</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            a: starter,
            b: starter,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">double_a</span></span>(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-keyword">Self</span> {
        <span class="hljs-keyword">Self</span> {
            a: <span class="hljs-keyword">self</span>.a * <span class="hljs-number">2</span>,
            b: <span class="hljs-keyword">self</span>.b,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_foo</span></span>(<span class="hljs-keyword">self</span>) -&gt; Foo {
        Foo {
            inner: <span class="hljs-keyword">self</span>.a + <span class="hljs-keyword">self</span>.b,
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> x = FooBuilder::new(<span class="hljs-number">10</span>)
        .double_a()
        .into_foo();

    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:#?}"</span>, x);
}
</code></pre></pre>
<p>In this example, there is no direct way to create a <code class="hljs">Foo</code> object. We must create a <code class="hljs">FooBuilder</code>, and properly initialize it before we can obtain the <code class="hljs">Foo</code> object we want.</p>
<p>This minimal example encodes two states:</p>
<ul>
<li><code class="hljs">FooBuilder</code>, which represents an "unconfigured", or "configuration in process" state</li>
<li><code class="hljs">Foo</code>, which represents a "configured", or "ready to use" state.</li>
</ul>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#strong-types" id="strong-types">Strong Types</a></h2>
<p>Because Rust has a <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing">Strong Type System</a>, there is no easy way to magically create an instance of <code class="hljs">Foo</code>, or to turn a <code class="hljs">FooBuilder</code> into a <code class="hljs">Foo</code> without calling the <code class="hljs">into_foo()</code> method. Additionally, calling the <code class="hljs">into_foo()</code> method consumes the original <code class="hljs">FooBuilder</code> structure, meaning it can not be reused without the creation of a new instance.</p>
<p>This allows us to represent the states of our system as types, and to include the necessary actions for state transitions into the methods that exchange one type for another. By creating a <code class="hljs">FooBuilder</code>, and exchanging it for a <code class="hljs">Foo</code> object, we have walked through the steps of a basic state machine.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#peripherals-as-state-machines" id="peripherals-as-state-machines">Peripherals as State Machines</a></h1>
<p>The peripherals of a microcontroller can be thought of as set of state machines. For example, the configuration of a simplified <a href="https://en.wikipedia.org/wiki/General-purpose_input/output">GPIO pin</a> could be represented as the following tree of states:</p>
<ul>
<li>Disabled</li>
<li>Enabled
<ul>
<li>Configured as Output
<ul>
<li>Output: High</li>
<li>Output: Low</li>
</ul>
</li>
<li>Configured as Input
<ul>
<li>Input: High Resistance</li>
<li>Input: Pulled Low</li>
<li>Input: Pulled High</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>If the peripheral starts in the <code class="hljs">Disabled</code> mode, to move to the <code class="hljs">Input: High Resistance</code> mode, we must perform the following steps:</p>
<ol>
<li>Disabled</li>
<li>Enabled</li>
<li>Configured as Input</li>
<li>Input: High Resistance</li>
</ol>
<p>If we wanted to move from <code class="hljs">Input: High Resistance</code> to <code class="hljs">Input: Pulled Low</code>, we must perform the following steps:</p>
<ol>
<li>Input: High Resistance</li>
<li>Input: Pulled Low</li>
</ol>
<p>Similarly, if we want to move a GPIO pin from configured as <code class="hljs">Input: Pulled Low</code> to <code class="hljs">Output: High</code>, we must perform the following steps:</p>
<ol>
<li>Input: Pulled Low</li>
<li>Configured as Input</li>
<li>Configured as Output</li>
<li>Output: High</li>
</ol>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#hardware-representation" id="hardware-representation">Hardware Representation</a></h2>
<p>Typically the states listed above are set by writing values to given registers mapped to a GPIO peripheral. Let's define an imaginary GPIO Configuration Register to illustrate this:</p>
<table><thead><tr><th align="right">Name</th><th align="right">Bit Number(s)</th><th align="right">Value</th><th align="right">Meaning</th><th align="right">Notes</th></tr></thead><tbody>
<tr><td align="right">enable</td><td align="right">0</td><td align="right">0</td><td align="right">disabled</td><td align="right">Disables the GPIO</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">enabled</td><td align="right">Enables the GPIO</td></tr>
<tr><td align="right">direction</td><td align="right">1</td><td align="right">0</td><td align="right">input</td><td align="right">Sets the direction to Input</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">output</td><td align="right">Sets the direction to Output</td></tr>
<tr><td align="right">input_mode</td><td align="right">2..3</td><td align="right">00</td><td align="right">hi-z</td><td align="right">Sets the input as high resistance</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">01</td><td align="right">pull-low</td><td align="right">Input pin is pulled low</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">10</td><td align="right">pull-high</td><td align="right">Input pin is pulled high</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">11</td><td align="right">n/a</td><td align="right">Invalid state. Do not set</td></tr>
<tr><td align="right">output_mode</td><td align="right">4</td><td align="right">0</td><td align="right">set-low</td><td align="right">Output pin is driven low</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">set-high</td><td align="right">Output pin is driven high</td></tr>
<tr><td align="right">input_status</td><td align="right">5</td><td align="right">x</td><td align="right">in-val</td><td align="right">0 if input is &lt; 1.5v, 1 if input &gt;= 1.5v</td></tr>
</tbody></table>
<p>We <em>could</em> expose the following structure in Rust to control this GPIO:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">/// GPIO interface</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GpioConfig</span></span> {
    <span class="hljs-comment">/// GPIO Configuration structure generated by svd2rust</span>
    periph: GPIO_CONFIG,
}

<span class="hljs-keyword">impl</span> Gpio {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_enable</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_enabled: <span class="hljs-built_in">bool</span>) {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_direction</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_output: <span class="hljs-built_in">bool</span>) {
        <span class="hljs-keyword">self</span>.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_input_mode</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, variant: InputMode) {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_output_mode</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_high: <span class="hljs-built_in">bool</span>) {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_input_status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> {
        <span class="hljs-keyword">self</span>.periph.read().input_status().bit_is_set()
    }
}
</code></pre>
<p>However, this would allow us to modify certain registers that do not make sense. For example, what happens if we set the <code class="hljs">output_mode</code> field when our GPIO is configured as an input? </p>
<p>In general, use of this structure would allow us to reach states not defined by our state machine above: e.g. an output that is pulled low, or an input that is set high. For some hardware, this may not matter. On other hardware, it could cause unexpected or undefined behavior!</p>
<p>Although this interface is convenient to write, it doesn't enforce the design contracts set out by our hardware implementation.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#design-contracts" id="design-contracts">Design Contracts</a></h1>
<p>In our last chapter, we wrote an interface that <em>didn't</em> enforce design contracts. Let's take another look at our imaginary GPIO configuration register:</p>
<table><thead><tr><th align="right">Name</th><th align="right">Bit Number(s)</th><th align="right">Value</th><th align="right">Meaning</th><th align="right">Notes</th></tr></thead><tbody>
<tr><td align="right">enable</td><td align="right">0</td><td align="right">0</td><td align="right">disabled</td><td align="right">Disables the GPIO</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">enabled</td><td align="right">Enables the GPIO</td></tr>
<tr><td align="right">direction</td><td align="right">1</td><td align="right">0</td><td align="right">input</td><td align="right">Sets the direction to Input</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">output</td><td align="right">Sets the direction to Output</td></tr>
<tr><td align="right">input_mode</td><td align="right">2..3</td><td align="right">00</td><td align="right">hi-z</td><td align="right">Sets the input as high resistance</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">01</td><td align="right">pull-low</td><td align="right">Input pin is pulled low</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">10</td><td align="right">pull-high</td><td align="right">Input pin is pulled high</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">11</td><td align="right">n/a</td><td align="right">Invalid state. Do not set</td></tr>
<tr><td align="right">output_mode</td><td align="right">4</td><td align="right">0</td><td align="right">set-low</td><td align="right">Output pin is driven low</td></tr>
<tr><td align="right"></td><td align="right"></td><td align="right">1</td><td align="right">set-high</td><td align="right">Output pin is driven high</td></tr>
<tr><td align="right">input_status</td><td align="right">5</td><td align="right">x</td><td align="right">in-val</td><td align="right">0 if input is &lt; 1.5v, 1 if input &gt;= 1.5v</td></tr>
</tbody></table>
<p>If we instead checked the state before making use of the underlying hardware, enforcing our design contracts at runtime, we might write code that looks like this instead:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">/// GPIO interface</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GpioConfig</span></span> {
    <span class="hljs-comment">/// GPIO Configuration structure generated by svd2rust</span>
    periph: GPIO_CONFIG,
}

<span class="hljs-keyword">impl</span> Gpio {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_enable</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_enabled: <span class="hljs-built_in">bool</span>) {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.enable().set_bit(is_enabled)
        });
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_direction</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_output: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), ()&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().enable().bit_is_clear() {
            <span class="hljs-comment">// Must be enabled to set direction</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">self</span>.periph.modify(|r, w| {
            w.direction().set_bit(is_output)
        });

        <span class="hljs-literal">Ok</span>(())
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_input_mode</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, variant: InputMode) -&gt; <span class="hljs-built_in">Result</span>&lt;(), ()&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().enable().bit_is_clear() {
            <span class="hljs-comment">// Must be enabled to set input mode</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().direction().bit_is_set() {
            <span class="hljs-comment">// Direction must be input</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.input_mode().variant(variant)
        });

        <span class="hljs-literal">Ok</span>(())
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_output_status</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, is_high: <span class="hljs-built_in">bool</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;(), ()&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().enable().bit_is_clear() {
            <span class="hljs-comment">// Must be enabled to set output status</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().direction().bit_is_clear() {
            <span class="hljs-comment">// Direction must be output</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.output_mode.set_bit(is_high)
        });

        <span class="hljs-literal">Ok</span>(())
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_input_status</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">Result</span>&lt;<span class="hljs-built_in">bool</span>, ()&gt; {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().enable().bit_is_clear() {
            <span class="hljs-comment">// Must be enabled to get status</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.periph.read().direction().bit_is_set() {
            <span class="hljs-comment">// Direction must be input</span>
            <span class="hljs-keyword">return</span> <span class="hljs-literal">Err</span>(());
        }

        <span class="hljs-literal">Ok</span>(<span class="hljs-keyword">self</span>.periph.read().input_status().bit_is_set())
    }
}
</code></pre>
<p>Because we need to enforce the restrictions on the hardware, we end up doing a lot of runtime checking which wastes time and resources, and this code will be much less pleasant for the developer to use.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#type-states" id="type-states">Type States</a></h2>
<p>But what if instead, we used Rust's type system to enforce the state transition rules? Take this example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">/// GPIO interface</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GpioConfig</span></span>&lt;ENABLED, DIRECTION, MODE&gt; {
    <span class="hljs-comment">/// GPIO Configuration structure generated by svd2rust</span>
    periph: GPIO_CONFIG,
    enabled: ENABLED,
    direction: DIRECTION,
    mode: MODE,
}

<span class="hljs-comment">// Type states for MODE in GpioConfig</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Disabled</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Enabled</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Output</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Input</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PulledLow</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PulledHigh</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HighZ</span></span>;
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">DontCare</span></span>;

<span class="hljs-comment">/// These functions may be used on any GPIO Pin</span>
<span class="hljs-keyword">impl</span>&lt;EN, DIR, IN_MODE&gt; GpioConfig&lt;EN, DIR, IN_MODE&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_disabled</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Disabled, DontCare, DontCare&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.enable.disabled());
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Disabled,
            direction: DontCare,
            mode: DontCare,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_enabled_input</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.input()
             .input_mode.high_z()
        });
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_enabled_output</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Output, DontCare&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| {
            w.enable.enabled()
             .direction.output()
             .input_mode.set_high()
        });
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Enabled,
            direction: Output,
            mode: DontCare,
        }
    }
}

<span class="hljs-comment">/// This function may be used on an Output Pin</span>
<span class="hljs-keyword">impl</span> GpioConfig&lt;Enabled, Output, DontCare&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_bit</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, set_high: <span class="hljs-built_in">bool</span>) {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.output_mode.set_bit(set_high));
    }
}

<span class="hljs-comment">/// These methods may be used on any enabled input GPIO</span>
<span class="hljs-keyword">impl</span>&lt;IN_MODE&gt; GpioConfig&lt;Enabled, Input, IN_MODE&gt; {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">bit_is_set</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">bool</span> {
        <span class="hljs-keyword">self</span>.periph.read().input_status.bit_is_set()
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_input_high_z</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.input_mode().high_z());
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Enabled,
            direction: Input,
            mode: HighZ,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_input_pull_down</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Input, PulledLow&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.input_mode().pull_low());
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledLow,
        }
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_input_pull_up</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Input, PulledHigh&gt; {
        <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.input_mode().pull_high());
        GpioConfig {
            periph: <span class="hljs-keyword">self</span>.periph,
            enabled: Enabled,
            direction: Input,
            mode: PulledHigh,
        }
    }
}
</code></pre>
<p>Now let's see what the code using this would look like:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">/*
 * Example 1: Unconfigured to High-Z input
 */</span>
<span class="hljs-keyword">let</span> pin: GpioConfig&lt;Disabled, _, _&gt; = get_gpio();

<span class="hljs-comment">// Can't do this, pin isn't enabled!</span>
<span class="hljs-comment">// pin.into_input_pull_down();</span>

<span class="hljs-comment">// Now turn the pin from unconfigured to a high-z input</span>
<span class="hljs-keyword">let</span> input_pin = pin.into_enabled_input();

<span class="hljs-comment">// Read from the pin</span>
<span class="hljs-keyword">let</span> pin_state = input_pin.bit_is_set();

<span class="hljs-comment">// Can't do this, input pins don't have this interface!</span>
<span class="hljs-comment">// input_pin.set_bit(true);</span>

<span class="hljs-comment">/*
 * Example 2: High-Z input to Pulled Low input
 */</span>
<span class="hljs-keyword">let</span> pulled_low = input_pin.into_input_pull_down();
<span class="hljs-keyword">let</span> pin_state = pulled_low.bit_is_set();

<span class="hljs-comment">/*
 * Example 3: Pulled Low input to Output, set high
 */</span>
<span class="hljs-keyword">let</span> output_pin = pulled_low.into_enabled_output();
output_pin.set_bit(<span class="hljs-literal">false</span>);

<span class="hljs-comment">// Can't do this, output pins don't have this interface!</span>
<span class="hljs-comment">// output_pin.into_input_pull_down();</span>
</code></pre>
<p>This is definitely a convenient way to store the state of the pin, but why do it this way? Why is this better than storing the state as an <code class="hljs">enum</code> inside of our <code class="hljs">GpioConfig</code> structure?</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#compile-time-functional-safety" id="compile-time-functional-safety">Compile Time Functional Safety</a></h2>
<p>Because we are enforcing our design constraints entirely at compile time, this incurs no runtime cost. It is impossible to set an output mode when you have a pin in an input mode. Instead, you must walk through the states by converting it to an output pin, and then setting the output mode. Because of this, there is no runtime penalty due to checking the current state before executing a function.</p>
<p>Also, because these states are enforced by the type system, there is no longer room for errors by consumers of this interface. If they try to perform an illegal state transition, the code will not compile!</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#zero-cost-abstractions" id="zero-cost-abstractions">Zero Cost Abstractions</a></h1>
<p>Type states are also an excellent example of Zero Cost Abstractions - the ability to move certain behaviors to compile time execution or analysis. These type states contain no actual data, and are instead used as markers. Since they contain no data, they have no actual representation in memory at runtime:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::mem::size_of;

<span class="hljs-keyword">let</span> _ = size_of::&lt;Enabled&gt;();    <span class="hljs-comment">// == 0</span>
<span class="hljs-keyword">let</span> _ = size_of::&lt;Input&gt;();      <span class="hljs-comment">// == 0</span>
<span class="hljs-keyword">let</span> _ = size_of::&lt;PulledHigh&gt;(); <span class="hljs-comment">// == 0</span>
<span class="hljs-keyword">let</span> _ = size_of::&lt;GpioConfig&lt;Enabled, Input, PulledHigh&gt;&gt;(); <span class="hljs-comment">// == 0</span>
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#zero-sized-types" id="zero-sized-types">Zero Sized Types</a></h2>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Enabled</span></span>;
</code></pre>
<p>Structures defined like this are called Zero Sized Types, as they contain no actual data. Although these types act "real" at compile time - you can copy them, move them, take references to them, etc., however the optimizer will completely strip them away.</p>
<p>In this snippet of code:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">into_input_high_z</span></span>(<span class="hljs-keyword">self</span>) -&gt; GpioConfig&lt;Enabled, Input, HighZ&gt; {
    <span class="hljs-keyword">self</span>.periph.modify(|_r, w| w.input_mode().high_z());
    GpioConfig {
        periph: <span class="hljs-keyword">self</span>.periph,
        enabled: Enabled,
        direction: Input,
        mode: HighZ,
    }
}
</code></pre>
<p>The GpioConfig we return never exists at runtime. Calling this function will generally boil down to a single assembly instruction - storing a constant register value to a register location. This means that the type state interface we've developed is a zero cost abstraction - it uses no more CPU, RAM, or code space tracking the state of <code class="hljs">GpioConfig</code>, and renders to the same machine code as a direct register access.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#nesting" id="nesting">Nesting</a></h2>
<p>In general, these abstractions may be nested as deeply as you would like. As long as all components used are zero sized types, the whole structure will not exist at runtime.</p>
<p>For complex or deeply nested structures, it may be tedious to define all possible combinations of state. In these cases, macros may be used to generate all implementations.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#portability" id="portability">Portability</a></h1>
<p>In embedded environments portability is a very important topic: Every vendor and even each family from a single manufacturer offers different peripherals and capabilities and similarly the ways to interact with the peripherals will vary.</p>
<p>A common way to equalize such differences is via a layer called Hardware Abstraction layer or <strong>HAL</strong>.</p>
<blockquote>
<p>Hardware abstractions are sets of routines in software that emulate some platform-specific details, giving programs direct access to the hardware resources.</p>
<p>They often allow programmers to write device-independent, high performance applications by providing standard operating system (OS) calls to hardware.</p>
<p><em>Wikipedia: <a href="https://en.wikipedia.org/wiki/Hardware_abstraction">Hardware Abstraction Layer</a></em></p>
</blockquote>
<p>Embedded systems are a bit special in this regard since we typically do not have operating systems and user installable software but firmware images which are compiled as a whole as well as a number of other constraints. So while the traditional approach as defined by Wikipedia could potentially work it is likely not the most productive approach to ensure portability.</p>
<p>How do we do this in Rust? Enter <strong>embedded-hal</strong>...</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#what-is-embedded-hal" id="what-is-embedded-hal">What is embedded-hal?</a></h2>
<p>In a nutshell it is a set of traits which define implementation contracts between <strong>HAL implementations</strong>, <strong>drivers</strong> and <strong>applications (or firmwares)</strong>. Those contracts include both capabilities (i.e. if a trait is implemented for a certain type, the <strong>HAL implementation</strong> provides a certain capability) and methods (i.e. if you can construct a type implementing a trait it is guaranteed that you have the methods specified in the trait available).</p>
<p>A typical layering might look like this:</p>
<p><img src="./The Embedded Rust Book_files/rust_layers.svg" alt=""></p>
<p>Some of the defined traits in <strong>embedded-hal</strong> are:</p>
<ul>
<li>GPIO (input and output pins)</li>
<li>Serial communication</li>
<li>I2C</li>
<li>SPI</li>
<li>Timers/Countdowns</li>
<li>Analog Digital Conversion</li>
</ul>
<p>The main reason for having the <strong>embedded-hal</strong> traits and crates implementing and using them is to keep complexity in check. If you consider that an application might have to implement the use of the peripheral in the hardware as well as the application and potentially drivers for additional hardware components, then it should be easy to see that the re-usability is very limited. Expressed mathematically, if <strong>M</strong> is the number of peripheral HAL implementations and <strong>N</strong> the number of drivers then if we were to reinvent the wheel for every application then we would end up with <strong>M*N</strong> implementations while by using the <em>API</em> provided by the <strong>embedded-hal</strong> traits will make the implementation complexity approach <strong>M+N</strong>. Of course there're additional benefits to be had, such as less trial-and-error due to a well-defined and ready-to-use APIs.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#users-of-the-embedded-hal" id="users-of-the-embedded-hal">Users of the embedded-hal</a></h2>
<p>As said above there are three main users of the HAL:</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#hal-implementation" id="hal-implementation">HAL implementation</a></h3>
<p>A HAL implementation provides the interfacing between the hardware and the users of the HAL traits. Typical implementations consist of three parts:</p>
<ul>
<li>One or more hardware specific types</li>
<li>Functions to create and initialize such a type, often providing various configuration options (speed, operation mode, use pins, etc.)</li>
<li>one or more <code class="hljs">trait</code> <code class="hljs">impl</code> of <strong>embedded-hal</strong> traits for that type</li>
</ul>
<p>Such a <strong>HAL implementation</strong> can come in various flavours:</p>
<ul>
<li>Via low-level hardware access, e.g. via registers</li>
<li>Via operating system, e.g. by using the <code class="hljs">sysfs</code> under Linux</li>
<li>Via adapter, e.g. a mock of types for unit testing</li>
<li>Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander</li>
</ul>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#driver" id="driver">Driver</a></h3>
<p>A driver implements a set of custom functionality for an internal or external component, connected to a peripheral implementing the embedded-hal traits. Typical examples for such drivers include various sensors (temperature, magnetometer, accelerometer, light), display devices (LED arrays, LCD displays) and actuators (motors, transmitters).</p>
<p>A driver has to be initialized with an instance of type that implements a certain <code class="hljs">trait</code> of the embedded-hal which is ensured via trait bound and provides its own type instance with a custom set of methods allowing to interact with the driven device.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#application" id="application">Application</a></h3>
<p>The application binds the various parts together and ensures that the desired functionality is achieved. When porting between different systems, this is the part which requires the most adaptation efforts, since the application needs to correctly initialize the real hardware via the HAL implementation and the initialisation of different hardware differs, sometimes drastically so. Also the user choice often plays a big role, since components can be physically connected to different terminals, hardware buses sometimes need external hardware to match the configuration or there are different trade-offs to be made in the use of internal peripherals (e.g. multiple timers with different capabilities are available or peripherals conflict with others).</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#concurrency" id="concurrency">Concurrency</a></h1>
<p>Concurrency happens whenever different parts of your program might execute
at different times or out of order. In an embedded context, this includes:</p>
<ul>
<li>interrupt handlers, which run whenever the associated interrupt happens,</li>
<li>various forms of multithreading, where your microprocessor regularly swaps
between parts of your program,</li>
<li>and in some systems, multiple-core microprocessors, where each core can be
independently running a different part of your program at the same time.</li>
</ul>
<p>Since many embedded programs need to deal with interrupts, concurrency will
usually come up sooner or later, and it's also where many subtle and difficult
bugs can occur. Luckily, Rust provides a number of abstractions and safety
guarantees to help us write correct code.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#no-concurrency" id="no-concurrency">No Concurrency</a></h2>
<p>The simplest concurrency for an embedded program is no concurrency: your
software consists of a single main loop which just keeps running, and there
are no interrupts at all. Sometimes this is perfectly suited to the problem
at hand! Typically your loop will read some inputs, perform some processing,
and write some outputs.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> peripherals = setup_peripherals();
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> inputs = read_inputs(&amp;peripherals);
        <span class="hljs-keyword">let</span> outputs = process(inputs);
        write_outputs(&amp;peripherals, outputs);
    }
}
</code></pre>
<p>Since there's no concurrency, there's no need to worry about sharing data
between parts of your program or synchronising access to peripherals. If
you can get away with such a simple approach this can be a great solution.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#global-mutable-data" id="global-mutable-data">Global Mutable Data</a></h2>
<p>Unlike non-embedded Rust, we will not usually have the luxury of creating
heap allocations and passing references to that data into a newly-created
thread. Instead our interrupt handlers might be called at any time and must
know how to access whatever shared memory we are using. At the lowest level,
this means we must have <em>statically allocated</em> mutable memory, which
both the interrupt handler and the main code can refer to.</p>
<p>In Rust, such <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#accessing-or-modifying-a-mutable-static-variable"><code class="hljs">static mut</code></a> variables are always unsafe to read or write,
because without taking special care, you might trigger a race condition,
where your access to the variable is interrupted halfway through by an
interrupt which also accesses that variable.</p>
<p>For an example of how this behaviour can cause subtle errors in your code,
consider an embedded program which counts rising edges of some input signal
in each one-second period (a frequency counter):</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> state = read_signal_level();
        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            <span class="hljs-comment">// DANGER - Not actually safe! Could cause data races.</span>
            <span class="hljs-keyword">unsafe</span> { COUNTER += <span class="hljs-number">1</span> };
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-keyword">unsafe</span> { COUNTER = <span class="hljs-number">0</span>; }
}
</code></pre>
<p>Each second, the timer interrupt sets the counter back to 0. Meanwhile, the
main loop continually measures the signal, and incremements the counter when
it sees a change from low to high. We've had to use <code class="hljs">unsafe</code> to access
<code class="hljs">COUNTER</code>, as it's <code class="hljs">static mut</code>, and that means we're promising the compiler
we won't cause any undefined behaviour. Can you spot the race condition? The
increment on <code class="hljs">COUNTER</code> is <em>not</em> guaranteed to be atomic — in fact, on most
embedded platforms, it will be split into a load, then the increment, then
a store. If the interrupt fired after the load but before the store, the
reset back to 0 would be ignored after the interrupt returns — and we would
count twice as many transitions for that period.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#critical-sections" id="critical-sections">Critical Sections</a></h2>
<p>So, what can we do about data races? A simple approach is to use <em>critical
sections</em>, a context where interrupts are disabled. By wrapping the access to
<code class="hljs">COUNTER</code> in <code class="hljs">main</code> in a critical section, we can be sure the timer interrupt
will not fire until we're finished incrementing <code class="hljs">COUNTER</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> COUNTER: <span class="hljs-built_in">u32</span> = <span class="hljs-number">0</span>;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> state = read_signal_level();
        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            <span class="hljs-comment">// New critical section ensures synchronised access to COUNTER</span>
            cortex_m::interrupt::free(|_| {
                <span class="hljs-keyword">unsafe</span> { COUNTER += <span class="hljs-number">1</span> };
            });
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-keyword">unsafe</span> { COUNTER = <span class="hljs-number">0</span>; }
}
</code></pre>
<p>In this example we use <code class="hljs">cortex_m::interrupt::free</code>, but other platforms will
have similar mechanisms for executing code in a critical section. This is also
the same as disabling interrupts, running some code, and then re-enabling
interrupts.</p>
<p>Note we didn't need to put a critical section inside the timer interrupt,
for two reasons:</p>
<ul>
<li>Writing 0 to <code class="hljs">COUNTER</code> can't be affected by a race since we don't read it</li>
<li>It will never be interrupted by the <code class="hljs">main</code> thread anyway</li>
</ul>
<p>If <code class="hljs">COUNTER</code> was being shared by multiple interrupt handlers that might
<em>preempt</em> each other, then each one might require a critical section as well.</p>
<p>This solves our immediate problem, but we're still left writing a lot of
<code class="hljs">unsafe</code> code which we need to carefully reason about, and we might be using
critical sections needlessly — which comes at a cost to overhead and interrupt
latency and jitter.</p>
<p>It's worth noting that while a critical section guarantees no interrupts will
fire, it does not provide an exclusivity guarantee on multi-core systems!  The
other core could be happily accessing the same memory as your core, even
without interrupts. You will need stronger synchronisation primitives if you
are using multiple cores.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#atomic-access" id="atomic-access">Atomic Access</a></h2>
<p>On some platforms, atomic instructions are available, which provide guarantees
about read-modify-write operations. Specifically for Cortex-M, <code class="hljs">thumbv6</code>
(Cortex-M0) does not provide atomic instructions, while <code class="hljs">thumbv7</code> (Cortex-M3
and above) do. These instructions give an alternative to the heavy-handed
disabling of all interrupts: we can attempt the increment, it will succeed most
of the time, but if it was interrupted it will automatically retry the entire
increment operation. These atomic operations are safe even across multiple
cores.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::sync::atomic::{AtomicUsize, Ordering};

<span class="hljs-keyword">static</span> COUNTER: AtomicUsize = AtomicUsize::new(<span class="hljs-number">0</span>);

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> state = read_signal_level();
        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            <span class="hljs-comment">// Use `fetch_add` to atomically add 1 to COUNTER</span>
            COUNTER.fetch_add(<span class="hljs-number">1</span>, Ordering::Relaxed);
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-comment">// Use `store` to write 0 directly to COUNTER</span>
    COUNTER.store(<span class="hljs-number">0</span>, Ordering::Relaxed)
}
</code></pre>
<p>This time <code class="hljs">COUNTER</code> is a safe <code class="hljs">static</code> variable. Thanks to the <code class="hljs">AtomicUsize</code>
type <code class="hljs">COUNTER</code> can be safely modified from both the interrupt handler and the
main thread without disabling interrupts. When possible, this is a better
solution — but it may not be supported on your platform.</p>
<p>A note on <a href="https://doc.rust-lang.org/core/sync/atomic/enum.Ordering.html"><code class="hljs">Ordering</code></a>: this affects how the compiler and hardware may reorder
instructions, and also has consequences on cache visibility. Assuming that the
target is a single core platform <code class="hljs">Relaxed</code> is sufficient and the most efficient
choice in this particular case. Stricter ordering will cause the compiler to
emit memory barriers around the atomic operations; depending on what you're
using atomics for you may or may not need this! The precise details of the
atomic model are complicated and best described elsewhere.</p>
<p>For more details on atomics and ordering, see the <a href="https://doc.rust-lang.org/nomicon/atomics.html">nomicon</a>.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#abstractions-send-and-sync" id="abstractions-send-and-sync">Abstractions, Send, and Sync</a></h2>
<p>None of the above solutions are especially satisfactory. They require <code class="hljs">unsafe</code>
blocks which must be very carefully checked and are not ergonomic. Surely we
can do better in Rust!</p>
<p>We can abstract our counter into a safe interface which can be safely used
anywhere else in our code. For this example we'll use the critical-section
counter, but you could do something very similar with atomics.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::cell::UnsafeCell;
<span class="hljs-keyword">use</span> cortex_m::interrupt;

<span class="hljs-comment">// Our counter is just a wrapper around UnsafeCell&lt;u32&gt;, which is the heart</span>
<span class="hljs-comment">// of interior mutability in Rust. By using interior mutability, we can have</span>
<span class="hljs-comment">// COUNTER be `static` instead of `static mut`, but still able to mutate</span>
<span class="hljs-comment">// its counter value.</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSCounter</span></span>(UnsafeCell&lt;<span class="hljs-built_in">u32</span>&gt;);

<span class="hljs-keyword">const</span> CS_COUNTER_INIT: CSCounter = CSCounter(UnsafeCell::new(<span class="hljs-number">0</span>));

<span class="hljs-keyword">impl</span> CSCounter {
    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">reset</span></span>(&amp;<span class="hljs-keyword">self</span>, _cs: &amp;interrupt::CriticalSection) {
        <span class="hljs-comment">// By requiring a CriticalSection be passed in, we know we must</span>
        <span class="hljs-comment">// be operating inside a CriticalSection, and so can confidently</span>
        <span class="hljs-comment">// use this unsafe block (required to call UnsafeCell::get).</span>
        <span class="hljs-keyword">unsafe</span> { *<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.get() = <span class="hljs-number">0</span> };
    }

    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">increment</span></span>(&amp;<span class="hljs-keyword">self</span>, _cs: &amp;interrupt::CriticalSection) {
        <span class="hljs-keyword">unsafe</span> { *<span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.get() += <span class="hljs-number">1</span> };
    }
}

<span class="hljs-comment">// Required to allow static CSCounter. See explanation below.</span>
<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> CSCounter {}

<span class="hljs-comment">// COUNTER is no longer `mut` as it uses interior mutability;</span>
<span class="hljs-comment">// therefore it also no longer requires unsafe blocks to access.</span>
<span class="hljs-keyword">static</span> COUNTER: CSCounter = CS_COUNTER_INIT;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> state = read_signal_level();
        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            <span class="hljs-comment">// No unsafe here!</span>
            interrupt::free(|cs| COUNTER.increment(cs));
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-comment">// We do need to enter a critical section here just to obtain a valid</span>
    <span class="hljs-comment">// cs token, even though we know no other interrupt could pre-empt</span>
    <span class="hljs-comment">// this one.</span>
    interrupt::free(|cs| COUNTER.reset(cs));

    <span class="hljs-comment">// We could use unsafe code to generate a fake CriticalSection if we</span>
    <span class="hljs-comment">// really wanted to, avoiding the overhead:</span>
    <span class="hljs-comment">// let cs = unsafe { interrupt::CriticalSection::new() };</span>
}
</code></pre>
<p>We've moved our <code class="hljs">unsafe</code> code to inside our carefully-planned abstraction,
and now our appplication code does not contain any <code class="hljs">unsafe</code> blocks.</p>
<p>This design requires the application pass a <code class="hljs">CriticalSection</code> token in:
these tokens are only safely generated by <code class="hljs">interrupt::free</code>, so by requiring
one be passed in, we ensure we are operating inside a critical section, without
having to actually do the lock ourselves. This guarantee is provided statically
by the compiler: there won't be any runtime overhead associated with <code class="hljs">cs</code>.
If we had multiple counters, they could all be given the same <code class="hljs">cs</code>, without
requiring multiple nested critical sections.</p>
<p>This also brings up an important topic for concurrency in Rust: the
<a href="https://doc.rust-lang.org/nomicon/send-and-sync.html"><code class="hljs">Send</code> and <code class="hljs">Sync</code></a> traits. To summarise the Rust book, a type is Send
when it can safely be moved to another thread, while it is Sync when
it can be safely shared between multiple threads. In an embedded context,
we consider interrupts to be executing in a separate thread to the application
code, so variables accessed by both an interrupt and the main code must be
Sync.</p>
<p>For most types in Rust, both of these traits are automatically derived for you
by the compiler. However, because <code class="hljs">CSCounter</code> contains an <a href="https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html"><code class="hljs">UnsafeCell</code></a>, it is
not Sync, and therefore we could not make a <code class="hljs">static CSCounter</code>: <code class="hljs">static</code>
variables <em>must</em> be Sync, since they can be accessed by multiple threads.</p>
<p>To tell the compiler we have taken care that the <code class="hljs">CSCounter</code> is in fact safe
to share between threads, we implement the Sync trait explicitly. As with the
previous use of critical sections, this is only safe on single-core platforms:
with multiple cores you would need to go to greater lengths to ensure safety.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#mutexes" id="mutexes">Mutexes</a></h2>
<p>We've created a useful abstraction specific to our counter problem, but
there are many common abstractions used for concurrency.</p>
<p>One such <em>synchronisation primitive</em> is a mutex, short for mutual exclusion.
These constructs ensure exclusive access to a variable, such as our counter. A
thread can attempt to <em>lock</em> (or <em>acquire</em>) the mutex, and either succeeds
immediately, or blocks waiting for the lock to be acquired, or returns an error
that the mutex could not be locked. While that thread holds the lock, it is
granted access to the protected data. When the thread is done, it <em>unlocks</em> (or
<em>releases</em>) the mutex, allowing another thread to lock it. In Rust, we would
usually implement the unlock using the <a href="https://doc.rust-lang.org/core/ops/trait.Drop.html"><code class="hljs">Drop</code></a> trait to ensure it is always
released when the mutex goes out of scope.</p>
<p>Using a mutex with interrupt handlers can be tricky: it is not normally
acceptable for the interrupt handler to block, and it would be especially
disastrous for it to block waiting for the main thread to release a lock,
since we would then <em>deadlock</em> (the main thread will never release the lock
because execution stays in the interrupt handler). Deadlocking is not
considered unsafe: it is possible even in safe Rust.</p>
<p>To avoid this behaviour entirely, we could implement a mutex which requires
a critical section to lock, just like our counter example. So long as the
critical section must last as long as the lock, we can be sure we have
exclusive access to the wrapped variable without even needing to track
the lock/unlock state of the mutex.</p>
<p>This is in fact done for us in the <code class="hljs">cortex_m</code> crate! We could have written
our counter using it:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::cell::Cell;
<span class="hljs-keyword">use</span> cortex_m::interrupt::Mutex;

<span class="hljs-keyword">static</span> COUNTER: Mutex&lt;Cell&lt;<span class="hljs-built_in">u32</span>&gt;&gt; = Mutex::new(Cell::new(<span class="hljs-number">0</span>));

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-keyword">let</span> state = read_signal_level();
        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            interrupt::free(|cs|
                COUNTER.borrow(cs).set(COUNTER.borrow(cs).get() + <span class="hljs-number">1</span>));
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-comment">// We still need to enter a critical section here to satisfy the Mutex.</span>
    interrupt::free(|cs| COUNTER.borrow(cs).set(<span class="hljs-number">0</span>));
}
</code></pre>
<p>We're now using <a href="https://doc.rust-lang.org/core/cell/struct.Cell.html"><code class="hljs">Cell</code></a>, which along with its sibling <code class="hljs">RefCell</code> is used to
provide safe interior mutability. We've already seen <code class="hljs">UnsafeCell</code> which is
the bottom layer of interior mutability in Rust: it allows you to obtain
multiple mutable references to its value, but only with unsafe code. A <code class="hljs">Cell</code>
is like an <code class="hljs">UnsafeCell</code> but it provides a safe interface: it only permits
taking a copy of the current value or replacing it, not taking a reference,
and since it is not Sync, it cannot be shared between threads. These
constraints mean it's safe to use, but we couldn't use it directly in a
<code class="hljs">static</code> variable as a <code class="hljs">static</code> must be Sync.</p>
<p>So why does the example above work? The <code class="hljs">Mutex&lt;T&gt;</code> implements Sync for any
<code class="hljs">T</code> which is Send — such as a <code class="hljs">Cell</code>. It can do this safely because it only
gives access to its contents during a critical section. We're therefore able
to get a safe counter with no unsafe code at all!</p>
<p>This is great for simple types like the <code class="hljs">u32</code> of our counter, but what about
more complex types which are not Copy? An extremely common example in an
embedded context is a peripheral struct, which generally are not Copy.
For that we can turn to <code class="hljs">RefCell</code>.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#sharing-peripherals" id="sharing-peripherals">Sharing Peripherals</a></h2>
<p>Device crates generated using <code class="hljs">svd2rust</code> and similar abstractions provide
safe access to peripherals by enforcing that only one instance of the
peripheral struct can exist at a time. This ensures safety, but makes it
difficult to access a peripheral from both the main thread and an interrupt
handler.</p>
<p>To safely share peripheral access, we can use the <code class="hljs">Mutex</code> we saw before. We'll
also need to use <a href="https://doc.rust-lang.org/core/cell/struct.RefCell.html"><code class="hljs">RefCell</code></a>, which uses a runtime check to ensure only one
reference to a peripheral is given out at a time. This has more overhead than
the plain <code class="hljs">Cell</code>, but since we are giving out references rather than copies,
we must be sure only one exists at a time.</p>
<p>Finally, we'll also have to account for somehow moving the peripheral into
the shared variable after it has been initialised in the main code. To do
this we can use the <code class="hljs">Option</code> type, initialised to <code class="hljs">None</code> and later set to
the instance of the peripheral.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::cell::RefCell;
<span class="hljs-keyword">use</span> cortex_m::interrupt::{<span class="hljs-keyword">self</span>, Mutex};
<span class="hljs-keyword">use</span> stm32f4::stm32f405;

<span class="hljs-keyword">static</span> MY_GPIO: Mutex&lt;RefCell&lt;<span class="hljs-built_in">Option</span>&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(<span class="hljs-literal">None</span>));

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-comment">// Obtain the peripheral singletons and configure it.</span>
    <span class="hljs-comment">// This example is from an svd2rust-generated crate, but</span>
    <span class="hljs-comment">// most embedded device crates will be similar.</span>
    <span class="hljs-keyword">let</span> dp = stm32f405::Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> gpioa = &amp;dp.GPIOA;

    <span class="hljs-comment">// Some sort of configuration function.</span>
    <span class="hljs-comment">// Assume it sets PA0 to an input and PA1 to an output.</span>
    configure_gpio(gpioa);

    <span class="hljs-comment">// Store the GPIOA in the mutex, moving it.</span>
    interrupt::free(|cs| MY_GPIO.borrow(cs).replace(<span class="hljs-literal">Some</span>(dp.GPIOA)));
    <span class="hljs-comment">// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to</span>
    <span class="hljs-comment">// access it via the mutex.</span>

    <span class="hljs-comment">// Be careful to enable the interrupt only after setting MY_GPIO:</span>
    <span class="hljs-comment">// otherwise the interrupt might fire while it still contains None,</span>
    <span class="hljs-comment">// and as-written (with `unwrap()`), it would panic.</span>
    set_timer_1hz();
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> last_state = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// We'll now read state as a digital input, via the mutex</span>
        <span class="hljs-keyword">let</span> state = interrupt::free(|cs| {
            <span class="hljs-keyword">let</span> gpioa = MY_GPIO.borrow(cs).borrow();
            gpioa.as_ref().unwrap().idr.read().idr0().bit_is_set()
        });

        <span class="hljs-keyword">if</span> state &amp;&amp; !last_state {
            <span class="hljs-comment">// Set PA1 high if we've seen a rising edge on PA0.</span>
            interrupt::free(|cs| {
                <span class="hljs-keyword">let</span> gpioa = MY_GPIO.borrow(cs).borrow();
                gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
            });
        }
        last_state = state;
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    <span class="hljs-comment">// This time in the interrupt we'll just clear PA0.</span>
    interrupt::free(|cs| {
        <span class="hljs-comment">// We can use `unwrap()` because we know the interrupt wasn't enabled</span>
        <span class="hljs-comment">// until after MY_GPIO was set; otherwise we should handle the potential</span>
        <span class="hljs-comment">// for a None value.</span>
        <span class="hljs-keyword">let</span> gpioa = MY_GPIO.borrow(cs).borrow();
        gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().clear_bit());
    });
}
</code></pre>
<p>That's quite a lot to take in, so let's break down the important lines.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">static</span> MY_GPIO: Mutex&lt;RefCell&lt;<span class="hljs-built_in">Option</span>&lt;stm32f405::GPIOA&gt;&gt;&gt; =
    Mutex::new(RefCell::new(<span class="hljs-literal">None</span>));
</code></pre>
<p>Our shared variable is now a <code class="hljs">Mutex</code> around a <code class="hljs">RefCell</code> which contains an
<code class="hljs">Option</code>. The <code class="hljs">Mutex</code> ensures we only have access during a critical section,
and therefore makes the variable Sync, even though a plain <code class="hljs">RefCell</code> would not
be Sync. The <code class="hljs">RefCell</code> gives us interior mutability with references, which
we'll need to use our <code class="hljs">GPIOA</code>. The <code class="hljs">Option</code> lets us initialise this variable
to something empty, and only later actually move the variable in. We cannot
access the peripheral singleton statically, only at runtime, so this is
required.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs">interrupt::free(|cs| MY_GPIO.borrow(cs).replace(<span class="hljs-literal">Some</span>(dp.GPIOA)));
</code></pre>
<p>Inside a critical section we can call <code class="hljs">borrow()</code> on the mutex, which gives us
a reference to the <code class="hljs">RefCell</code>. We then call <code class="hljs">replace()</code> to move our new value
into the <code class="hljs">RefCell</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs">interrupt::free(|cs| {
    <span class="hljs-keyword">let</span> gpioa = MY_GPIO.borrow(cs).borrow();
    gpioa.as_ref().unwrap().odr.modify(|_, w| w.odr1().set_bit());
});
</code></pre>
<p>Finally we use <code class="hljs">MY_GPIO</code> in a safe and concurrent fashion. The critical section
prevents the interrupt firing as usual, and lets us borrow the mutex.  The
<code class="hljs">RefCell</code> then gives us an <code class="hljs">&amp;Option&lt;GPIOA&gt;</code>, and tracks how long it remains
borrowed - once that reference goes out of scope, the <code class="hljs">RefCell</code> will be updated
to indicate it is no longer borrowed.</p>
<p>Since we can't move the <code class="hljs">GPIOA</code> out of the <code class="hljs">&amp;Option</code>, we need to convert it to
an <code class="hljs">&amp;Option&lt;&amp;GPIOA&gt;</code> with <code class="hljs">as_ref()</code>, which we can finally <code class="hljs">unwrap()</code> to obtain
the <code class="hljs">&amp;GPIOA</code> which lets us modify the peripheral.</p>
<p>If we need a mutable references to shared resources, then <code class="hljs">borrow_mut</code> and <code class="hljs">deref_mut</code>
should be used instead. The following code shows an example using the TIM2 timer.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">use</span> core::cell::RefCell;
<span class="hljs-keyword">use</span> core::ops::DerefMut;
<span class="hljs-keyword">use</span> cortex_m::interrupt::{<span class="hljs-keyword">self</span>, Mutex};
<span class="hljs-keyword">use</span> cortex_m::asm::wfi;
<span class="hljs-keyword">use</span> stm32f4::stm32f405;

<span class="hljs-keyword">static</span> G_TIM: Mutex&lt;RefCell&lt;<span class="hljs-built_in">Option</span>&lt;Timer&lt;stm32::TIM2&gt;&gt;&gt;&gt; =
    Mutex::new(RefCell::new(<span class="hljs-literal">None</span>));

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> cp = cm::Peripherals::take().unwrap();
    <span class="hljs-keyword">let</span> dp = stm32f405::Peripherals::take().unwrap();

    <span class="hljs-comment">// Some sort of timer configuration function.</span>
    <span class="hljs-comment">// Assume it configures the TIM2 timer, its NVIC interrupt,</span>
    <span class="hljs-comment">// and finally starts the timer.</span>
    <span class="hljs-keyword">let</span> tim = configure_timer_interrupt(&amp;<span class="hljs-keyword">mut</span> cp, dp);

    interrupt::free(|cs| {
        G_TIM.borrow(cs).replace(<span class="hljs-literal">Some</span>(tim));
    });

    <span class="hljs-keyword">loop</span> {
        wfi();
    }
}

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">timer</span></span>() {
    interrupt::free(|cs| {
        <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(<span class="hljs-keyword">ref</span> <span class="hljs-keyword">mut</span> tim)) =  G_TIM.borrow(cs).borrow_mut().deref_mut() {
            tim.start(<span class="hljs-number">1</span>.hz());
        }
    });
}

</code></pre>
<blockquote>
<p><strong>NOTE</strong></p>
<p>At the moment, the <code class="hljs">cortex-m</code> crate hides const versions of some functions
(including <code class="hljs">Mutex::new()</code>) behind the <code class="hljs">const-fn</code> feature. So you need to add
the <code class="hljs">const-fn</code> feature as a dependency for cortex-m in the Cargo.toml to make
the above examples work:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[dependencies.cortex-m]</span>
<span class="hljs-attr">version</span>=<span class="hljs-string">"0.6.0"</span>
<span class="hljs-attr">features</span>=[<span class="hljs-string">"const-fn"</span>]
</code></pre>
<p>Meanwhile, <code class="hljs">const-fn</code> has been working on stable Rust for some time now.
So this additional switch in Cargo.toml will not be needed as soon as 
it is enabled in <code class="hljs">cortex-m</code> by default.</p>
</blockquote>
<p>Whew! This is safe, but it is also a little unwieldy. Is there anything else
we can do?</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#rtfm" id="rtfm">RTFM</a></h2>
<p>One alternative is the <a href="https://github.com/japaric/cortex-m-rtfm">RTFM framework</a>, short for Real Time For the Masses. It
enforces static priorities and tracks accesses to <code class="hljs">static mut</code> variables
("resources") to statically ensure that shared resources are always accessed
safely, without requiring the overhead of always entering critical sections and
using reference counting (as in <code class="hljs">RefCell</code>). This has a number of advantages such
as guaranteeing no deadlocks and giving extremely low time and memory overhead.</p>
<p>The framework also includes other features like message passing, which reduces
the need for explicit shared state, and the ability to schedule tasks to run at
a given time, which can be used to implement periodic tasks. Check out <a href="https://japaric.github.io/cortex-m-rtfm/book/">the
documentation</a> for more information!</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#real-time-operating-systems" id="real-time-operating-systems">Real Time Operating Systems</a></h2>
<p>Another common model for embedded concurrency is the real-time operating system
(RTOS). While currently less well explored in Rust, they are widely used in
traditional embedded development. Open source examples include <a href="https://freertos.org/">FreeRTOS</a> and
<a href="http://chibios.org/">ChibiOS</a>. These RTOSs provide support for running multiple application threads
which the CPU swaps between, either when the threads yield control (called
cooperative multitasking) or based on a regular timer or interrupts (preemptive
multitasking). The RTOS typically provide mutexes and other synchronisation
primitives, and often interoperate with hardware features such as DMA engines.</p>
<p>At the time of writing there are not many Rust RTOS examples to point to,
but it's an interesting area so watch this space!</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#multiple-cores" id="multiple-cores">Multiple Cores</a></h2>
<p>It is becoming more common to have two or more cores in embedded processors,
which adds an extra layer of complexity to concurrency. All the examples using
a critical section (including the <code class="hljs">cortex_m::interrupt::Mutex</code>) assume the only
other execution thread is the interrupt thread, but on a multi-core system
that's no longer true. Instead, we'll need synchronisation primitives designed
for multiple cores (also called SMP, for symmetric multi-processing).</p>
<p>These typically use the atomic instructions we saw earlier, since the
processing system will ensure that atomicity is maintained over all cores.</p>
<p>Covering these topics in detail is currently beyond the scope of this book,
but the general patterns are the same as for the single-core case.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#collections" id="collections">Collections</a></h1>
<p>Eventually you'll want to use dynamic data structures (AKA collections) in your
program. <code class="hljs">std</code> provides a set of common collections: <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html"><code class="hljs">Vec</code></a>, <a href="https://doc.rust-lang.org/std/string/struct.String.html"><code class="hljs">String</code></a>,
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html"><code class="hljs">HashMap</code></a>, etc. All the collections implemented in <code class="hljs">std</code> use a global dynamic
memory allocator (AKA the heap).</p>
<p>As <code class="hljs">core</code> is, by definition, free of memory allocations these implementations
are not available there, but they can be found in the <em>unstable</em> <code class="hljs">alloc</code> crate
that's shipped with the compiler.</p>
<p>If you need collections, a heap allocated implementation is not your only
option. You can also use <em>fixed capacity</em> collections; one such implementation
can be found in the <a href="https://crates.io/crates/heapless"><code class="hljs">heapless</code></a> crate.</p>
<p>In this section, we'll explore and compare these two implementations.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#using-alloc" id="using-alloc">Using <code class="hljs">alloc</code></a></h2>
<p>The <code class="hljs">alloc</code> crate is shipped with the standard Rust distribution. To import the
crate you can directly <code class="hljs">use</code> it <em>without</em> declaring it as a dependency in your
<code class="hljs">Cargo.toml</code> file.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![feature(alloc)]</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> alloc;

<span class="hljs-keyword">use</span> alloc::vec::<span class="hljs-built_in">Vec</span>;
</code></pre>
<p>To be able to use any collection you'll first need use the <code class="hljs">global_allocator</code>
attribute to declare the global allocator your program will use. It's required
that the allocator you select implements the <a href="https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html"><code class="hljs">GlobalAlloc</code></a> trait.</p>
<p>For completeness and to keep this section as self-contained as possible we'll
implement a simple bump pointer allocator and use that as the global allocator.
However, we <em>strongly</em> suggest you use a battle tested allocator from crates.io
in your program instead of this allocator.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">// Bump pointer allocator implementation</span>

<span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> cortex_m;

<span class="hljs-keyword">use</span> core::alloc::GlobalAlloc;
<span class="hljs-keyword">use</span> core::ptr;

<span class="hljs-keyword">use</span> cortex_m::interrupt;

<span class="hljs-comment">// Bump pointer allocator for *single* core systems</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BumpPointerAlloc</span></span> {
    head: UnsafeCell&lt;<span class="hljs-built_in">usize</span>&gt;,
    end: <span class="hljs-built_in">usize</span>,
}

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> BumpPointerAlloc {}

<span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span> GlobalAlloc <span class="hljs-keyword">for</span> BumpPointerAlloc {
    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">alloc</span></span>(&amp;<span class="hljs-keyword">self</span>, layout: Layout) -&gt; *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span> {
        <span class="hljs-comment">// `interrupt::free` is a critical section that makes our allocator safe</span>
        <span class="hljs-comment">// to use from within interrupts</span>
        interrupt::free(|_| {
            <span class="hljs-keyword">let</span> head = <span class="hljs-keyword">self</span>.head.get();

            <span class="hljs-keyword">let</span> align = layout.align();
            <span class="hljs-keyword">let</span> res = *head % align;
            <span class="hljs-keyword">let</span> start = <span class="hljs-keyword">if</span> res == <span class="hljs-number">0</span> { *head } <span class="hljs-keyword">else</span> { *head + align - res };
            <span class="hljs-keyword">if</span> start + align &gt; <span class="hljs-keyword">self</span>.end {
                <span class="hljs-comment">// a null pointer signal an Out Of Memory condition</span>
                ptr::null_mut()
            } <span class="hljs-keyword">else</span> {
                *head = start + align;
                start <span class="hljs-keyword">as</span> *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>
            }
        })
    }

    <span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">dealloc</span></span>(&amp;<span class="hljs-keyword">self</span>, _: *<span class="hljs-keyword">mut</span> <span class="hljs-built_in">u8</span>, _: Layout) {
        <span class="hljs-comment">// this allocator never deallocates memory</span>
    }
}

<span class="hljs-comment">// Declaration of the global memory allocator</span>
<span class="hljs-comment">// NOTE the user must ensure that the memory region `[0x2000_0100, 0x2000_0200]`</span>
<span class="hljs-comment">// is not used by other parts of the program</span>
<span class="hljs-meta">#[global_allocator]</span>
<span class="hljs-keyword">static</span> HEAP: BumpPointerAlloc = BumpPointerAlloc {
    head: UnsafeCell::new(<span class="hljs-number">0x2000_0100</span>),
    end: <span class="hljs-number">0x2000_0200</span>,
};
</code></pre>
<p>Apart from selecting a global allocator the user will also have to define how
Out Of Memory (OOM) errors are handled using the <em>unstable</em>
<code class="hljs">alloc_error_handler</code> attribute.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#![feature(alloc_error_handler)]</span>

<span class="hljs-keyword">use</span> cortex_m::asm;

<span class="hljs-meta">#[alloc_error_handler]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">on_oom</span></span>(_layout: Layout) -&gt; ! {
    asm::bkpt();

    <span class="hljs-keyword">loop</span> {}
}
</code></pre>
<p>Once all that is in place, the user can finally use the collections in <code class="hljs">alloc</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> xs = <span class="hljs-built_in">Vec</span>::new();

    xs.push(<span class="hljs-number">42</span>);
    <span class="hljs-built_in">assert!</span>(xs.pop(), <span class="hljs-literal">Some</span>(<span class="hljs-number">42</span>));

    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// ..</span>
    }
}
</code></pre>
<p>If you have used the collections in the <code class="hljs">std</code> crate then these will be familiar
as they are exact same implementation.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#using-heapless" id="using-heapless">Using <code class="hljs">heapless</code></a></h2>
<p><code class="hljs">heapless</code> requires no setup as its collections don't depend on a global memory
allocator. Just <code class="hljs">use</code> its collections and proceed to instantiate them:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> heapless; <span class="hljs-comment">// v0.4.x</span>

<span class="hljs-keyword">use</span> heapless::<span class="hljs-built_in">Vec</span>;
<span class="hljs-keyword">use</span> heapless::consts::*;

<span class="hljs-meta">#[entry]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() -&gt; ! {
    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> xs: <span class="hljs-built_in">Vec</span>&lt;_, U8&gt; = <span class="hljs-built_in">Vec</span>::new();

    xs.push(<span class="hljs-number">42</span>).unwrap();
    <span class="hljs-built_in">assert_eq!</span>(xs.pop(), <span class="hljs-literal">Some</span>(<span class="hljs-number">42</span>));
}
</code></pre>
<p>You'll note two differences between these collections and the ones in <code class="hljs">alloc</code>.</p>
<p>First, you have to declare upfront the capacity of the collection. <code class="hljs">heapless</code>
collections never reallocate and have fixed capacities; this capacity is part of
the type signature of the collection. In this case we have declared that <code class="hljs">xs</code>
has a capacity of 8 elements that is the vector can, at most, hold 8 elements.
This is indicated by the <code class="hljs">U8</code> (see <a href="https://crates.io/crates/typenum"><code class="hljs">typenum</code></a>) in the type signature.</p>
<p>Second, the <code class="hljs">push</code> method, and many other methods, return a <code class="hljs">Result</code>. Since the
<code class="hljs">heapless</code> collections have fixed capacity all operations that insert elements
into the collection can potentially fail. The API reflects this problem by
returning a <code class="hljs">Result</code> indicating whether the operation succeeded or not. In
contrast, <code class="hljs">alloc</code> collections will reallocate themselves on the heap to increase
their capacity.</p>
<p>As of version v0.4.x all <code class="hljs">heapless</code> collections store all their elements inline.
This means that an operation like <code class="hljs">let x = heapless::Vec::new();</code> will allocate
the collection on the stack, but it's also possible to allocate the collection
on a <code class="hljs">static</code> variable, or even on the heap (<code class="hljs">Box&lt;Vec&lt;_, _&gt;&gt;</code>).</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#trade-offs" id="trade-offs">Trade-offs</a></h2>
<p>Keep these in mind when choosing between heap allocated, relocatable collections
and fixed capacity collections.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#out-of-memory-and-error-handling" id="out-of-memory-and-error-handling">Out Of Memory and error handling</a></h3>
<p>With heap allocations Out Of Memory is always a possibility and can occur in
any place where a collection may need to grow: for example, all
<code class="hljs">alloc::Vec.push</code> invocations can potentially generate an OOM condition. Thus
some operations can <em>implicitly</em> fail. Some <code class="hljs">alloc</code> collections expose
<code class="hljs">try_reserve</code> methods that let you check for potential OOM conditions when
growing the collection but you need be proactive about using them.</p>
<p>If you exclusively use <code class="hljs">heapless</code> collections and you don't use a memory
allocator for anything else then an OOM condition is impossible. Instead, you'll
have to deal with collections running out of capacity on a case by case basis.
That is you'll have deal with <em>all</em> the <code class="hljs">Result</code>s returned by methods like
<code class="hljs">Vec.push</code>.</p>
<p>OOM failures can be harder to debug than say <code class="hljs">unwrap</code>-ing on all <code class="hljs">Result</code>s
returned by <code class="hljs">heapless::Vec.push</code> because the observed location of failure may
<em>not</em> match with the location of the cause of the problem. For example, even
<code class="hljs">vec.reserve(1)</code> can trigger an OOM if the allocator is nearly exhausted because
some other collection was leaking memory (memory leaks are possible in safe
Rust).</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#memory-usage" id="memory-usage">Memory usage</a></h3>
<p>Reasoning about memory usage of heap allocated collections is hard because the
capacity of long lived collections can change at runtime. Some operations may
implicitly reallocate the collection increasing its memory usage, and some
collections expose methods like <code class="hljs">shrink_to_fit</code> that can potentially reduce the
memory used by the collection -- ultimately, it's up to the allocator to decide
whether to actually shrink the memory allocation or not. Additionally, the
allocator may have to deal with memory fragmentation which can increase the
<em>apparent</em> memory usage.</p>
<p>On the other hand if you exclusively use fixed capacity collections, store
most of them in <code class="hljs">static</code> variables and set a maximum size for the call stack
then the linker will detect if you try to use more memory than what's physically
available.</p>
<p>Furthermore, fixed capacity collections allocated on the stack will be reported
by <a href="https://doc.rust-lang.org/beta/unstable-book/compiler-flags/emit-stack-sizes.html"><code class="hljs">-Z emit-stack-sizes</code></a> flag which means that tools that analyze stack usage
(like <a href="https://crates.io/crates/stack-sizes"><code class="hljs">stack-sizes</code></a>) will include them in their analysis.</p>
<p>However, fixed capacity collections can <em>not</em> be shrunk which can result in
lower load factors (the ratio between the size of the collection and its
capacity) than what relocatable collections can achieve.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#worst-case-execution-time-wcet" id="worst-case-execution-time-wcet">Worst Case Execution Time (WCET)</a></h3>
<p>If are building time sensitive applications or hard real time applications then
you care, maybe a lot, about the worst case execution time of the different
parts of your program.</p>
<p>The <code class="hljs">alloc</code> collections can reallocate so the WCET of operations that may grow
the collection will also include the time it takes to reallocate the collection,
which itself depends on the <em>runtime</em> capacity of the collection. This makes it
hard to determine the WCET of, for example, the <code class="hljs">alloc::Vec.push</code> operation as
it depends on both the allocator being used and its runtime capacity.</p>
<p>On the other hand fixed capacity collections never reallocate so all operations
have a predictable execution time. For example, <code class="hljs">heapless::Vec.push</code> executes in
constant time.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#ease-of-use" id="ease-of-use">Ease of use</a></h3>
<p><code class="hljs">alloc</code> requires setting up a global allocator whereas <code class="hljs">heapless</code> does not.
However, <code class="hljs">heapless</code> requires you to pick the capacity of each collection that
you instantiate.</p>
<p>The <code class="hljs">alloc</code> API will be familiar to virtually every Rust developer. The
<code class="hljs">heapless</code> API tries to closely mimic the <code class="hljs">alloc</code> API but it will never be
exactly the same due to its explicit error handling -- some developers may feel
the explicit error handling is excessive or too cumbersome.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#tips-for-embedded-c-developers" id="tips-for-embedded-c-developers">Tips for embedded C developers</a></h1>
<p>This chapter collects a variety of tips that might be useful to experienced
embedded C developers looking to start writing Rust. It will especially
highlight how things you might already be used to in C are different in Rust.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#preprocessor" id="preprocessor">Preprocessor</a></h2>
<p>In embedded C it is very common to use the preprocessor for a variety of
purposes, such as:</p>
<ul>
<li>Compile-time selection of code blocks with <code class="hljs">#ifdef</code></li>
<li>Compile-time array sizes and computations</li>
<li>Macros to simplify common patterns (to avoid function call overhead)</li>
</ul>
<p>In Rust there is no preprocessor, and so many of these use cases are addressed
differently. In the rest of this section we cover various alternatives to
using the preprocessor.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#compile-time-code-selection" id="compile-time-code-selection">Compile-Time Code Selection</a></h3>
<p>The closest match to <code class="hljs">#ifdef ... #endif</code> in Rust are <a href="https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-section">Cargo features</a>. These
are a little more formal than the C preprocessor: all possible features are
explicitly listed per crate, and can only be either on or off. Features are
turned on when you list a crate as a dependency, and are additive: if any crate
in your dependency tree enables a feature for another crate, that feature will
be enabled for all users of that crate.</p>
<p>For example, you might have a crate which provides a library of signal
processing primitives. Each one might take some extra time to compile or
declare some large table of constants which you'd like to avoid. You could
declare a Cargo feature for each component in your <code class="hljs">Cargo.toml</code>:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[features]</span>
<span class="hljs-attr">FIR</span> = []
<span class="hljs-attr">IIR</span> = []
</code></pre>
<p>Then, in your code, use <code class="hljs">#[cfg(feature="FIR")]</code> to control what is included.</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring">
<span class="boring"><span class="hljs-meta">#![allow(unused_variables)]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
</span><span class="hljs-comment">/// In your top-level lib.rs</span>

<span class="boring">[cfg(feature=<span class="hljs-string">"FIR"</span>)]
</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> fir;

<span class="boring">[cfg(feature=<span class="hljs-string">"IIR"</span>)]
</span><span class="hljs-keyword">pub</span> <span class="hljs-keyword">mod</span> iir;
<span class="boring">}
</span></code></pre></pre>
<p>You can similarly include code blocks only if a feature is <em>not</em> enabled, or if
any combination of features are or are not enabled.</p>
<p>Additionally, Rust provides a number of automatically-set conditions you can
use, such as <code class="hljs">target_arch</code> to select different code based on architecture. For
full details of the conditional compilation support, refer to the
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> chapter of the Rust reference.</p>
<p>The conditional compilation will only apply to the next statement or block. If
a block can not be used in the current scope then the <code class="hljs">cfg</code> attribute will
need to be used multiple times.  It's worth noting that most of the time it is
better to simply include all the code and allow the compiler to remove dead
code when optimising: it's simpler for you and your users, and in general the
compiler will do a good job of removing unused code.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#compile-time-sizes-and-computation" id="compile-time-sizes-and-computation">Compile-Time Sizes and Computation</a></h3>
<p>Rust supports <code class="hljs">const fn</code>, functions which are guaranteed to be evaluable at
compile-time and can therefore be used where constants are required, such as
in the size of arrays. This can be used alongside features mentioned above,
for example:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring">
<span class="boring"><span class="hljs-meta">#![allow(unused_variables)]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
</span><span class="hljs-keyword">const</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">array_size</span></span>() -&gt; <span class="hljs-built_in">usize</span> {
<span class="boring">    [cfg(feature=<span class="hljs-string">"use_more_ram"</span>)]
</span>    { <span class="hljs-number">1024</span> }
<span class="boring">    [cfg(not(feature=<span class="hljs-string">"use_more_ram"</span>))]
</span>    { <span class="hljs-number">128</span> }
}

<span class="hljs-keyword">static</span> BUF: [<span class="hljs-built_in">u32</span>; array_size()] = [<span class="hljs-number">0u32</span>; array_size()];
<span class="boring">}
</span></code></pre></pre>
<p>These are new to stable Rust as of 1.31, so documentation is still sparse. The
functionality available to <code class="hljs">const fn</code> is also very limited at the time of
writing; in future Rust releases it is expected to expand on what is permitted
in a <code class="hljs">const fn</code>.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#macros" id="macros">Macros</a></h3>
<p>Rust provides an extremely powerful <a href="https://doc.rust-lang.org/book/ch19-06-macros.html">macro system</a>. While the C preprocessor
operates almost directly on the text of your source code, the Rust macro system
operates at a higher level. There are two varieties of Rust macro: <em>macros by
example</em> and <em>procedural macros</em>. The former are simpler and most common; they
look like function calls and can expand to a complete expression, statement,
item, or pattern. Procedural macros are more complex but permit extremely
powerful additions to the Rust language: they can transform arbitrary Rust
syntax into new Rust syntax.</p>
<p>In general, where you might have used a C preprocessor macro, you probably want
to see if a macro-by-example can do the job instead. They can be defined in
your crate and easily used by your own crate or exported for other users. Be
aware that since they must expand to complete expressions, statements, items,
or patterns, some use cases of C preprocessor macros will not work, for example
a macro that expands to part of a variable name or an incomplete set of items
in a list.</p>
<p>As with Cargo features, it is worth considering if you even need the macro. In
many cases a regular function is easier to understand and will be inlined to
the same code as a macro. The <code class="hljs">#[inline]</code> and <code class="hljs">#[inline(always)]</code> <a href="https://doc.rust-lang.org/reference/attributes.html#inline-attribute">attributes</a>
give you further control over this process, although care should be taken here
as well — the compiler will automatically inline functions from the same crate
where appropriate, so forcing it to do so inappropriately might actually lead
to decreased performance.</p>
<p>Explaining the entire Rust macro system is out of scope for this tips page, so
you are encouraged to consult the Rust documentation for full details.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#build-system" id="build-system">Build System</a></h2>
<p>Most Rust crates are built using Cargo (although it is not required). This
takes care of many difficult problems with traditional build systems. However,
you may wish to customise the build process. Cargo provides <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html"><code class="hljs">build.rs</code>
scripts</a> for this purpose. They are Rust scripts which can interact with the
Cargo build system as required.</p>
<p>Common use cases for build scripts include:</p>
<ul>
<li>provide build-time information, for example statically embedding the build
date or Git commit hash into your executable</li>
<li>generate linker scripts at build time depending on selected features or other
logic</li>
<li>change the Cargo build configuration</li>
<li>add extra static libraries to link against</li>
</ul>
<p>At present there is no support for post-build scripts, which you might
traditionally have used for tasks like automatic generation of binaries from
the build objects or printing build information.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#cross-compiling-1" id="cross-compiling-1">Cross-Compiling</a></h3>
<p>Using Cargo for your build system also simplifies cross-compiling. In most
cases it suffices to tell Cargo <code class="hljs">--target thumbv6m-none-eabi</code> and find a
suitable executable in <code class="hljs">target/thumbv6m-none-eabi/debug/myapp</code>.</p>
<p>For platforms not natively supported by Rust, you will need to build <code class="hljs">libcore</code>
for that target yourself. On such platforms, <a href="https://github.com/japaric/xargo">Xargo</a> can be used as a stand-in
for Cargo which automatically builds <code class="hljs">libcore</code> for you.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#iterators-vs-array-access" id="iterators-vs-array-access">Iterators vs Array Access</a></h2>
<p>In C you are probably used to accessing arrays directly by their index:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-c hljs cpp"><span class="hljs-keyword">int16_t</span> arr[<span class="hljs-number">16</span>];
<span class="hljs-keyword">int</span> i;
<span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(arr)/<span class="hljs-keyword">sizeof</span>(arr[<span class="hljs-number">0</span>]); i++) {
    process(arr[i]);
}
</code></pre>
<p>In Rust this is an anti-pattern: indexed access can be slower (as it needs to
be bounds checked) and may prevent various compiler optimisations. This is an
important distinction and worth repeating: Rust will check for out-of-bounds
access on manual array indexing to guarantee memory safety, while C will
happily index outside the array.</p>
<p>Instead, use iterators:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">0u16</span>; <span class="hljs-number">16</span>];
<span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> arr.iter() {
    process(*element);
}
</code></pre>
<p>Iterators provide a powerful array of functionality you would have to implement
manually in C, such as chaining, zipping, enumerating, finding the min or max,
summing, and more. Iterator methods can also be chained, giving very readable
data processing code.</p>
<p>See the <a href="https://doc.rust-lang.org/book/ch13-02-iterators.html">Iterators in the Book</a> and <a href="https://doc.rust-lang.org/core/iter/trait.Iterator.html">Iterator documentation</a> for more details.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#references-vs-pointers" id="references-vs-pointers">References vs Pointers</a></h2>
<p>In Rust, pointers (called <a href="https://doc.rust-lang.org/book/ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer"><em>raw pointers</em></a>) exist but are only used in specific
circumstances, as dereferencing them is always considered <code class="hljs">unsafe</code> -- Rust
cannot provide its usual guarantees about what might be behind the pointer.</p>
<p>In most cases, we instead use <em>references</em>, indicated by the <code class="hljs">&amp;</code> symbol, or
<em>mutable references</em>, indicated by <code class="hljs">&amp;mut</code>. References behave similarly to
pointers, in that they can be dereferenced to access the underlying values, but
they are a key part of Rust's ownership system: Rust will strictly enforce that
you may only have one mutable reference <em>or</em> multiple non-mutable references to
the same value at any given time.</p>
<p>In practice this means you have to be more careful about whether you need
mutable access to data: where in C the default is mutable and you must be
explicit about <code class="hljs">const</code>, in Rust the opposite is true.</p>
<p>One situation where you might still use raw pointers is interacting directly
with hardware (for example, writing a pointer to a buffer into a DMA peripheral
register), and they are also used under the hood for all peripheral access
crates to allow you to read and write memory-mapped registers.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#volatile-access" id="volatile-access">Volatile Access</a></h2>
<p>In C, individual variables may be marked <code class="hljs">volatile</code>, indicating to the compiler
that the value in the variable may change between accesses. Volatile variables
are commonly used in an embedded context for memory-mapped registers.</p>
<p>In Rust, instead of marking a variable as <code class="hljs">volatile</code>, we use specific methods
to perform volatile access: <a href="https://doc.rust-lang.org/core/ptr/fn.read_volatile.html"><code class="hljs">core::ptr::read_volatile</code></a> and
<a href="https://doc.rust-lang.org/core/ptr/fn.write_volatile.html"><code class="hljs">core::ptr::write_volatile</code></a>. These methods take a <code class="hljs">*const T</code> or a <code class="hljs">*mut T</code>
(<em>raw pointers</em>, as discussed above) and perform a volatile read or write.</p>
<p>For example, in C you might write:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-c hljs cpp"><span class="hljs-keyword">volatile</span> <span class="hljs-keyword">bool</span> signalled = <span class="hljs-literal">false</span>;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">ISR</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Signal that the interrupt has occurred</span>
    signalled = <span class="hljs-literal">true</span>;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">driver</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) {
        <span class="hljs-comment">// Sleep until signalled</span>
        <span class="hljs-keyword">while</span>(!signalled) { WFI(); }
        <span class="hljs-comment">// Reset signalled indicator</span>
        signalled = <span class="hljs-literal">false</span>;
        <span class="hljs-comment">// Perform some task that was waiting for the interrupt</span>
        run_task();
    }
}
</code></pre>
<p>The equivalent in Rust would use volatile methods on each access:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> SIGNALLED: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">false</span>;

<span class="hljs-meta">#[interrupt]</span>
<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">ISR</span></span>() {
    <span class="hljs-comment">// Signal that the interrupt has occurred</span>
    <span class="hljs-comment">// (In real code, you should consider a higher level primitive,</span>
    <span class="hljs-comment">//  such as an atomic type).</span>
    <span class="hljs-keyword">unsafe</span> { core::ptr::write_volatile(&amp;<span class="hljs-keyword">mut</span> SIGNALLED, <span class="hljs-literal">true</span>) };
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">driver</span></span>() {
    <span class="hljs-keyword">loop</span> {
        <span class="hljs-comment">// Sleep until signalled</span>
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">unsafe</span> { !core::ptr::read_volatile(&amp;SIGNALLED) } {}
        <span class="hljs-comment">// Reset signalled indicator</span>
        <span class="hljs-keyword">unsafe</span> { core::ptr::write_volatile(&amp;<span class="hljs-keyword">mut</span> SIGNALLED, <span class="hljs-literal">false</span>) };
        <span class="hljs-comment">// Perform some task that was waiting for the interrupt</span>
        run_task();
    }
}
</code></pre>
<p>A few things are worth noting in the code sample:</p>
<ul>
<li>We can pass <code class="hljs">&amp;mut SIGNALLED</code> into the function requiring <code class="hljs">*mut T</code>, since
<code class="hljs">&amp;mut T</code> automatically converts to a <code class="hljs">*mut T</code> (and the same for <code class="hljs">*const T</code>)</li>
<li>We need <code class="hljs">unsafe</code> blocks for the <code class="hljs">read_volatile</code>/<code class="hljs">write_volatile</code> methods,
since they are <code class="hljs">unsafe</code> functions. It is the programmer's responsibility
to ensure safe use: see the methods' documentation for further details.</li>
</ul>
<p>It is rare to require these functions directly in your code, as they will
usually be taken care of for you by higher-level libraries. For memory mapped
peripherals, the peripheral access crates will implement volatile access
automatically, while for concurrency primitives there are better abstractions
available (see the <a href="https://rust-embedded.github.io/book/concurrency/index.html">Concurrency chapter</a>).</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#packed-and-aligned-types" id="packed-and-aligned-types">Packed and Aligned Types</a></h2>
<p>In embedded C it is common to tell the compiler a variable must have a certain
alignment or a struct must be packed rather than aligned, usually to meet
specific hardware or protocol requirements.</p>
<p>In Rust this is controlled by the <code class="hljs">repr</code> attribute on a struct or union. The
default representation provides no guarantees of layout, so should not be used
for code that interoperates with hardware or C. The compiler may re-order
struct members or insert padding and the behaviour may change with future
versions of Rust.</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button></div><code class="language-rust hljs"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    x: <span class="hljs-built_in">u16</span>,
    y: <span class="hljs-built_in">u8</span>,
    z: <span class="hljs-built_in">u16</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> v = Foo { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:p} {:p} {:p}"</span>, &amp;v.x, &amp;v.y, &amp;v.z);
}

<span class="hljs-comment">// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2</span>
<span class="hljs-comment">// Note ordering has been changed to x, z, y to improve packing.</span>
</code></pre></pre>
<p>To ensure layouts that are interoperable with C, use <code class="hljs">repr(C)</code>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring"><span class="boring">[repr(C)]
</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    x: <span class="hljs-built_in">u16</span>,
    y: <span class="hljs-built_in">u8</span>,
    z: <span class="hljs-built_in">u16</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> v = Foo { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:p} {:p} {:p}"</span>, &amp;v.x, &amp;v.y, &amp;v.z);
}

<span class="hljs-comment">// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64</span>
<span class="hljs-comment">// Ordering is preserved and the layout will not change over time.</span>
<span class="hljs-comment">// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.</span>
</code></pre></pre>
<p>To ensure a packed representation, use <code class="hljs">repr(packed)</code>:</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring"><span class="boring">[repr(packed)]
</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    x: <span class="hljs-built_in">u16</span>,
    y: <span class="hljs-built_in">u8</span>,
    z: <span class="hljs-built_in">u16</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> v = Foo { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> };
    <span class="hljs-comment">// Unsafe is required to borrow a field of a packed struct.</span>
    <span class="hljs-keyword">unsafe</span> { <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:p} {:p} {:p}"</span>, &amp;v.x, &amp;v.y, &amp;v.z) };
}

<span class="hljs-comment">// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493</span>
<span class="hljs-comment">// No padding has been inserted between `y` and `z`, so now `z` is unaligned.</span>
</code></pre></pre>
<p>Note that using <code class="hljs">repr(packed)</code> also sets the alignment of the type to <code class="hljs">1</code>.</p>
<p>Finally, to specify a specific alignment, use <code class="hljs">repr(align(n))</code>, where <code class="hljs">n</code> is
the number of bytes to align to (and must be a power of two):</p>
<pre><pre class="playpen"><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button><button class="fa fa-play play-button" hidden="" title="Run this code" aria-label="Run this code"></button><button class="fa fa-expand" title="Show hidden lines" aria-label="Show hidden lines"></button></div><code class="language-rust hljs hide-boring"><span class="boring">[repr(C)]
[repr(align(<span class="hljs-number">4096</span>))]
</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Foo</span></span> {
    x: <span class="hljs-built_in">u16</span>,
    y: <span class="hljs-built_in">u8</span>,
    z: <span class="hljs-built_in">u16</span>,
}

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    <span class="hljs-keyword">let</span> v = Foo { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> };
    <span class="hljs-keyword">let</span> u = Foo { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span>, z: <span class="hljs-number">0</span> };
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:p} {:p} {:p}"</span>, &amp;v.x, &amp;v.y, &amp;v.z);
    <span class="hljs-built_in">println!</span>(<span class="hljs-string">"{:p} {:p} {:p}"</span>, &amp;u.x, &amp;u.y, &amp;u.z);
}

<span class="hljs-comment">// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004</span>
<span class="hljs-comment">// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004</span>
<span class="hljs-comment">// The two instances `u` and `v` have been placed on 4096-byte alignments,</span>
<span class="hljs-comment">// evidenced by the `000` at the end of their addresses.</span>
</code></pre></pre>
<p>Note we can combine <code class="hljs">repr(C)</code> with <code class="hljs">repr(align(n))</code> to obtain an aligned and
C-compatible layout. It is not permissible to combine <code class="hljs">repr(align(n))</code> with
<code class="hljs">repr(packed)</code>, since <code class="hljs">repr(packed)</code> sets the alignment to <code class="hljs">1</code>. It is also not
permissible for a <code class="hljs">repr(packed)</code> type to contain a <code class="hljs">repr(align(n))</code> type.</p>
<p>For further details on type layouts, refer to the <a href="https://doc.rust-lang.org/reference/type-layout.html">type layout</a> chapter of the
Rust Reference.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#other-resources-1" id="other-resources-1">Other Resources</a></h2>
<ul>
<li>In this book:
<ul>
<li><a href="https://rust-embedded.github.io/book/interoperability/c-with-rust.html">A little C with your Rust</a></li>
<li><a href="https://rust-embedded.github.io/book/interoperability/rust-with-c.html">A little Rust with your C</a></li>
</ul>
</li>
<li><a href="https://docs.rust-embedded.org/faq.html">The Rust Embedded FAQs</a></li>
<li><a href="http://blahg.josefsipek.net/?p=580">Rust Pointers for C Programmers</a></li>
<li><a href="https://github.com/diwic/reffers-rs/blob/master/docs/Pointers.md">I used to use pointers - now what?</a></li>
</ul>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#interoperability" id="interoperability">Interoperability</a></h1>
<p>Interoperability between Rust and C code is always dependent
on transforming data between the two languages.
For this purposes there are two dedicated modules
in the <code class="hljs">stdlib</code> called
<a href="https://doc.rust-lang.org/std/ffi/index.html"><code class="hljs">std::ffi</code></a> and
<a href="https://doc.rust-lang.org/std/os/raw/index.html"><code class="hljs">std::os::raw</code></a>.</p>
<p><code class="hljs">std::os::raw</code> deals with low-level primitive types that can
be converted implicitly by the compiler
because the memory layout between Rust and C
is similar enough or the same.</p>
<p><code class="hljs">std::ffi</code> provides some utility for converting more complex
types such as Strings, mapping both <code class="hljs">&amp;str</code> and <code class="hljs">String</code>
to C-types that are easier and safer to handle.</p>
<p>Neither of these modules are available in <code class="hljs">core</code>, but you can find a <code class="hljs">#![no_std]</code>
compatible version of <code class="hljs">std::ffi::{CStr,CString}</code> in the <a href="https://crates.io/crates/cstr_core"><code class="hljs">cstr_core</code></a> crate, and
most of the <code class="hljs">std::os::raw</code> types in the <a href="https://crates.io/crates/cty"><code class="hljs">cty</code></a> crate.</p>
<table><thead><tr><th>Rust type</th><th>Intermediate</th><th>C type</th></tr></thead><tbody>
<tr><td>String</td><td>CString</td><td>*char</td></tr>
<tr><td>&amp;str</td><td>CStr</td><td>*const char</td></tr>
<tr><td>()</td><td>c_void</td><td>void</td></tr>
<tr><td>u32 or u64</td><td>c_uint</td><td>unsigned int</td></tr>
<tr><td>etc</td><td>...</td><td>...</td></tr>
</tbody></table>
<p>As mentioned above, primitive types can be converted
by the compiler implicitly.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">unsafe</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(num: <span class="hljs-built_in">u32</span>) {
    <span class="hljs-keyword">let</span> c_num: c_uint = num;
    <span class="hljs-keyword">let</span> r_num: <span class="hljs-built_in">u32</span> = c_num;
}
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#interoperability-with-other-build-systems" id="interoperability-with-other-build-systems">Interoperability with other build systems</a></h2>
<p>A common requirement for including Rust in your embedded project is combining
Cargo with your existing build system, such as make or cmake.</p>
<p>We are collecting examples and use cases for this on our issue tracker in
<a href="https://github.com/rust-embedded/book/issues/61">issue #61</a>.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#interoperability-with-rtoss" id="interoperability-with-rtoss">Interoperability with RTOSs</a></h2>
<p>Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in
progress; especially calling RTOS functions from Rust can be tricky.</p>
<p>We are collecting examples and use cases for this on our issue tracker in
<a href="https://github.com/rust-embedded/book/issues/62">issue #62</a>.</p>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#a-little-c-with-your-rust" id="a-little-c-with-your-rust">A little C with your Rust</a></h1>
<p>Using C or C++ inside of a Rust project consists of two major parts:</p>
<ul>
<li>Wrapping the exposed C API for use with Rust</li>
<li>Building your C or C++ code to be integrated with the Rust code</li>
</ul>
<p>As C++ does not have a stable ABI for the Rust compiler to target, it is recommended to use the <code class="hljs">C</code> ABI when combining Rust with C or C++.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#defining-the-interface" id="defining-the-interface">Defining the interface</a></h2>
<p>Before consuming C or C++ code from Rust, it is necessary to define (in Rust) what data types and function signatures exist in the linked code. In C or C++, you would include a header (<code class="hljs">.h</code> or <code class="hljs">.hpp</code>) file which defines this data. In Rust, it is necessary to either manually translate these definitions to Rust, or use a tool to generate these definitions.</p>
<p>First, we will cover manually translating these definitions from C/C++ to Rust.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#wrapping-c-functions-and-datatypes" id="wrapping-c-functions-and-datatypes">Wrapping C functions and Datatypes</a></h3>
<p>Typically, libraries written in C or C++ will provide a header file defining all types and functions used in public interfaces. An example file may look like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C hljs"><span class="hljs-comment">/* File: cool.h */</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoolStruct</span> {</span>
    <span class="hljs-keyword">int</span> x;
    <span class="hljs-keyword">int</span> y;
} CoolStruct;

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cool_function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i, <span class="hljs-keyword">char</span> c, CoolStruct* cs)</span></span>;
</code></pre>
<p>When translated to Rust, this interface would look as such:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-comment">/* File: cool_bindings.rs */</span>
<span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoolStruct</span></span> {
    <span class="hljs-keyword">pub</span> x: cty::c_int,
    <span class="hljs-keyword">pub</span> y: cty::c_int,
}

<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cool_function</span></span>(
    i: cty::c_int,
    c: cty::c_char,
    cs: *<span class="hljs-keyword">mut</span> CoolStruct
);
</code></pre>
<p>Let's take a look at this definition one piece at a time, to explain each of the parts.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[repr(C)]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CoolStruct</span></span> { ... }
</code></pre>
<p>By default, Rust does not guarantee order, padding, or the size of data included in a <code class="hljs">struct</code>. In order to guarantee compatibility with C code, we include the <code class="hljs">#[repr(C)]</code> attribute, which instructs the Rust compiler to always use the same rules C does for organizing data within a struct.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">pub</span> x: cty::c_int,
<span class="hljs-keyword">pub</span> y: cty::c_int,
</code></pre>
<p>Due to the flexibility of how C or C++ defines an <code class="hljs">int</code> or <code class="hljs">char</code>, it is recommended to use primitive data types defined in <code class="hljs">cty</code>, which will map types from C to types in Rust</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">cool_function</span></span>( ... );
</code></pre>
<p>This statement defines the signature of a function that uses the C ABI, called <code class="hljs">cool_function</code>. By defining the signature without defining the body of the function, the definition of this function will need to be provided elsewhere, or linked into the final library or binary from a static library.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs">    i: cty::c_int,
    c: cty::c_char,
    cs: *<span class="hljs-keyword">mut</span> CoolStruct
</code></pre>
<p>Similar to our datatype above, we define the datatypes of the function arguments using C-compatible definitions. We also retain the same argument names, for clarity.</p>
<p>We have one new type here, <code class="hljs">*mut CoolStruct</code>. As C does not have a concept of Rust's references, which would look like this: <code class="hljs">&amp;mut CoolStruct</code>, we instead have a raw pointer. As dereferencing this pointer is <code class="hljs">unsafe</code>, and the pointer may in fact be a <code class="hljs">null</code> pointer, care must be taken to ensure the guarantees typical of Rust when interacting with C or C++ code.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#automatically-generating-the-interface" id="automatically-generating-the-interface">Automatically generating the interface</a></h3>
<p>Rather than manually generating these interfaces, which may be tedious and error prone, there is a tool called <a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a> which will perform these conversions automatically. For instructions of the usage of <a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>, please refer to the <a href="https://rust-lang.github.io/rust-bindgen/">bindgen user's manual</a>, however the typical process consists of the following:</p>
<ol>
<li>Gather all C or C++ headers defining interfaces or datatypes you would like to use with Rust</li>
<li>Write a <code class="hljs">bindings.h</code> file, which <code class="hljs">#include "..."</code>'s each of the files you gathered in step one</li>
<li>Feed this <code class="hljs">bindings.h</code> file, along with any compilation flags used to compile
your code into <code class="hljs">bindgen</code>. Tip: use <code class="hljs">Builder.ctypes_prefix("cty")</code> /
<code class="hljs">--ctypes-prefix=cty</code> and <code class="hljs">Builder.use_core()</code> to make the generated code <code class="hljs">#![no_std]</code> compatible.</li>
<li><code class="hljs">bindgen</code> will produce the generated Rust code to the output of the terminal window. This file may be piped to a file in your project, such as <code class="hljs">bindings.rs</code>. You may use this file in your Rust project to interact with C/C++ code compiled and linked as an external library. Tip: don't forget to use the <a href="https://crates.io/crates/cty"><code class="hljs">cty</code></a> crate if your types in the generated bindings are prefixed with <code class="hljs">cty</code>.</li>
</ol>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#building-your-cc-code" id="building-your-cc-code">Building your C/C++ code</a></h2>
<p>As the Rust compiler does not directly know how to compile C or C++ code (or code from any other language, which presents a C interface), it is necessary to compile your non-Rust code ahead of time.</p>
<p>For embedded projects, this most commonly means compiling the C/C++ code to a static archive (such as <code class="hljs">cool-library.a</code>), which can then be combined with your Rust code at the final linking step.</p>
<p>If the library you would like to use is already distributed as a static archive, it is not necessary to rebuild your code. Just convert the provided interface header file as described above, and include the static archive at compile/link time.</p>
<p>If your code exists as a source project, it will be necessary to compile your C/C++ code to a static library, either by triggering your existing build system (such as <code class="hljs">make</code>, <code class="hljs">CMake</code>, etc.), or by porting the necessary compilation steps to use a tool called the <code class="hljs">cc</code> crate. For both of these steps, it is necessary to use a <code class="hljs">build.rs</code> script.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#rust-buildrs-build-scripts" id="rust-buildrs-build-scripts">Rust <code class="hljs">build.rs</code> build scripts</a></h3>
<p>A <code class="hljs">build.rs</code> script is a file written in Rust syntax, that is executed on your compilation machine, AFTER dependencies of your project have been built, but BEFORE your project is built.</p>
<p>The full reference may be found <a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">here</a>. <code class="hljs">build.rs</code> scripts are useful for generating code (such as via <a href="https://github.com/rust-lang-nursery/rust-bindgen">bindgen</a>), calling out to external build systems such as <code class="hljs">Make</code>, or directly compiling C/C++ through use of the <code class="hljs">cc</code> crate</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#triggering-external-build-systems" id="triggering-external-build-systems">Triggering external build systems</a></h3>
<p>For projects with complex external projects or build systems, it may be easiest to use [<code class="hljs">std::process::Command</code>] to "shell out" to your other build systems by traversing relative paths, calling a fixed command (such as <code class="hljs">make library</code>), and then copying the resulting static library to the proper location in the <code class="hljs">target</code> build directory.</p>
<p>While your crate may be targeting a <code class="hljs">no_std</code> embedded platform, your <code class="hljs">build.rs</code> executes only on machines compiling your crate. This means you may use any Rust crates which will run on your compilation host.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#building-cc-code-with-the-cc-crate" id="building-cc-code-with-the-cc-crate">Building C/C++ code with the <code class="hljs">cc</code> crate</a></h3>
<p>For projects with limited dependencies or complexity, or for projects where it is difficult to modify the build system to produce a static library (rather than a final binary or executable), it may be easier to instead utilize the <a href="https://github.com/alexcrichton/cc-rs"><code class="hljs">cc</code> crate</a>, which provides an idiomatic Rust interface to the compiler provided by the host.</p>
<p>In the simplest case of compiling a single C file as a dependency to a static library, an example <code class="hljs">build.rs</code> script using the <a href="https://github.com/alexcrichton/cc-rs"><code class="hljs">cc</code> crate</a> would look like this:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> cc;

<span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>() {
    cc::Build::new()
        .file(<span class="hljs-string">"foo.c"</span>)
        .compile(<span class="hljs-string">"libfoo.a"</span>);
}
</code></pre>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#a-little-rust-with-your-c" id="a-little-rust-with-your-c">A little Rust with your C</a></h1>
<p>Using Rust code inside a C or C++ project mostly consists of two parts.</p>
<ul>
<li>Creating a C-friendly API in Rust</li>
<li>Embedding your Rust project into an external build system</li>
</ul>
<p>Apart from <code class="hljs">cargo</code> and <code class="hljs">meson</code>, most build systems don't have native Rust support.
So you're most likely best off just using <code class="hljs">cargo</code> for compiling your crate and
any dependencies.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#setting-up-a-project" id="setting-up-a-project">Setting up a project</a></h2>
<p>Create a new <code class="hljs">cargo</code> project as usual.</p>
<p>There are flags to tell <code class="hljs">cargo</code> to emit a systems library, instead of
its regular rust target.
This also allows you to set a different output name for your library,
if you want it to differ from the rest of your crate.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[lib]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"your_crate"</span>
<span class="hljs-attr">crate-type</span> = [<span class="hljs-string">"cdylib"</span>]      <span class="hljs-comment"># Creates dynamic lib</span>
<span class="hljs-comment"># crate-type = ["staticlib"] # Creates static lib</span>
</code></pre>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#building-a-c-api" id="building-a-c-api">Building a <code class="hljs">C</code> API</a></h2>
<p>Because C++ has no stable ABI for the Rust compiler to target, we use <code class="hljs">C</code> for
any interoperability between different languages. This is no exception when using Rust
inside of C and C++ code.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#no_mangle" id="no_mangle"><code class="hljs">#[no_mangle]</code></a></h3>
<p>The Rust compiler mangles symbol names differently than native code linkers expect.
As such, any function that Rust exports to be used outside of Rust needs to be told
not to be mangled by the compiler.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#extern-c" id="extern-c"><code class="hljs">extern "C"</code></a></h3>
<p>By default, any function you write in Rust will use the
Rust ABI (which is also not stabilized).
Instead, when building outwards facing FFI APIs we need to
tell the compiler to use the system ABI.</p>
<p>Depending on your platform, you might want to target a specific ABI version, which are
documented <a href="https://doc.rust-lang.org/reference/items/external-blocks.html">here</a>.</p>
<hr>
<p>Putting these parts together, you get a function that looks roughly like this.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rust_function</span></span>() {

}
</code></pre>
<p>Just as when using <code class="hljs">C</code> code in your Rust project you now need to transform data
from and to a form that the rest of the application will understand.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#linking-and-greater-project-context" id="linking-and-greater-project-context">Linking and greater project context.</a></h2>
<p>So then, that's one half of the problem solved.
How do you use this now?</p>
<p><strong>This very much depends on your project and/or build system</strong></p>
<p><code class="hljs">cargo</code> will create a <code class="hljs">my_lib.so</code>/<code class="hljs">my_lib.dll</code> or <code class="hljs">my_lib.a</code> file,
depending on your platform and settings. This library can simply be linked
by your build system.</p>
<p>However, calling a Rust function from C requires a header file to declare
the function signatures.</p>
<p>Every function in your Rust-ffi API needs to have a corresponding header function.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-rust ignore hljs"><span class="hljs-meta">#[no_mangle]</span>
<span class="hljs-keyword">pub</span> <span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">rust_function</span></span>() {}
</code></pre>
<p>would then become</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C hljs"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rust_function</span><span class="hljs-params">()</span></span>;
</code></pre>
<p>etc.</p>
<p>There is a tool to automate this process,
called <a href="https://github.com/eqrion/cbindgen">cbindgen</a> which analyses your Rust code
and then generates headers for your C and C++ projects from it.</p>
<p>At this point, using the Rust functions from C
is as simple as including the header and calling them!</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-C hljs"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">"my-rust-project.h"</span></span>
rust_function();
</code></pre>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#unsorted-topics" id="unsorted-topics">Unsorted topics</a></h1>
<h1><a class="header" href="https://rust-embedded.github.io/book/print.html#optimizations-the-speed-size-tradeoff" id="optimizations-the-speed-size-tradeoff">Optimizations: the speed size tradeoff</a></h1>
<p>Everyone wants their program to be super fast and super small but it's usually
not possible to have both characteristics. This section discusses the
different optimization levels that <code class="hljs">rustc</code> provides and how they affect the
execution time and binary size of a program.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#no-optimizations" id="no-optimizations">No optimizations</a></h2>
<p>This is the default. When you call <code class="hljs">cargo build</code> you use the development (AKA
<code class="hljs">dev</code>) profile. This profile is optimized for debugging so it enables debug
information and does <em>not</em> enable any optimizations, i.e. it uses <code class="hljs">-C opt-level = 0</code>.</p>
<p>At least for bare metal development, debuginfo is zero cost in the sense that it
won't occupy space in Flash / ROM so we actually recommend that you enable
debuginfo in the release profile -- it is disabled by default. That will let you
use breakpoints when debugging release builds.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[profile.release]</span>
<span class="hljs-comment"># symbols are nice and they don't increase the size on Flash</span>
<span class="hljs-attr">debug</span> = <span class="hljs-literal">true</span>
</code></pre>
<p>No optimizations is great for debugging because stepping through the code feels
like you are executing the program statement by statement, plus you can <code class="hljs">print</code>
stack variables and function arguments in GDB. When the code is optimized, trying
to print variables results in <code class="hljs">$0 = &lt;value optimized out&gt;</code> being printed.</p>
<p>The biggest downside of the <code class="hljs">dev</code> profile is that the resulting binary will be
huge and slow. The size is usually more of a problem because unoptimized
binaries can occupy dozens of KiB of Flash, which your target device may not
have -- the result: your unoptimized binary doesn't fit in your device!</p>
<p>Can we have smaller, debugger friendly binaries? Yes, there's a trick.</p>
<h3><a class="header" href="https://rust-embedded.github.io/book/print.html#optimizing-dependencies" id="optimizing-dependencies">Optimizing dependencies</a></h3>
<blockquote>
<p><strong>WARNING</strong> This section uses an unstable feature and it was last tested on
2018-09-18. Things may have changed since then!</p>
</blockquote>
<p>On nightly, there's a Cargo feature named <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-overrides"><code class="hljs">profile-overrides</code></a> that lets you
override the optimization level of dependencies. You can use that feature to
optimize all dependencies for size while keeping the top crate unoptimized and
debugger friendly.</p>
<p>Here's an example:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-comment"># Cargo.toml</span>
<span class="hljs-attr">cargo-features</span> = [<span class="hljs-string">"profile-overrides"</span>] <span class="hljs-comment"># +</span>
<span class="hljs-section">
[package]</span>
<span class="hljs-attr">name</span> = <span class="hljs-string">"app"</span>
<span class="hljs-comment"># ..</span>
<span class="hljs-section">
[profile.dev.overrides."*"]</span> <span class="hljs-comment"># +</span>
<span class="hljs-attr">opt-level</span> = <span class="hljs-string">"z"</span> <span class="hljs-comment"># +</span>
</code></pre>
<p>Without the override:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo size --bin app -- -A</span>
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 9060   0x8000400
.rodata               1708   0x8002780
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<p>With the override:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-console hljs shell"><span class="hljs-meta">$</span><span class="bash"> cargo size --bin app -- -A</span>
app  :
section               size        addr
.vector_table         1024   0x8000000
.text                 3490   0x8000400
.rodata               1100   0x80011c0
.data                    0  0x20000000
.bss                     4  0x20000000
</code></pre>
<p>That's a 6 KiB reduction in Flash usage without any loss in the debuggability of
the top crate. If you step into a dependency then you'll start seeing those
<code class="hljs">&lt;value optimized out&gt;</code> messages again but it's usually the case that you want
to debug the top crate and not the dependencies. And if you <em>do</em> need to debug a
dependency then you can use the <code class="hljs">profile-overrides</code> feature to exclude a
particular dependency from being optimized. See example below:</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-comment"># ..</span>

<span class="hljs-comment"># don't optimize the `cortex-m-rt` crate</span>
<span class="hljs-section">[profile.dev.overrides.cortex-m-rt]</span> <span class="hljs-comment"># +</span>
<span class="hljs-attr">opt-level</span> = <span class="hljs-number">0</span> <span class="hljs-comment"># +</span>

<span class="hljs-comment"># but do optimize all the other dependencies</span>
<span class="hljs-section">[profile.dev.overrides."*"]</span>
<span class="hljs-attr">codegen-units</span> = <span class="hljs-number">1</span> <span class="hljs-comment"># better optimizations</span>
<span class="hljs-attr">opt-level</span> = <span class="hljs-string">"z"</span>
</code></pre>
<p>Now the top crate and <code class="hljs">cortex-m-rt</code> are debugger friendly!</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#optimize-for-speed" id="optimize-for-speed">Optimize for speed</a></h2>
<p>As of 2018-09-18 <code class="hljs">rustc</code> supports three "optimize for speed" levels: <code class="hljs">opt-level = 1</code>, <code class="hljs">2</code> and <code class="hljs">3</code>. When you run <code class="hljs">cargo build --release</code> you are using the release
profile which defaults to <code class="hljs">opt-level = 3</code>.</p>
<p>Both <code class="hljs">opt-level = 2</code> and <code class="hljs">3</code> optimize for speed at the expense of binary size,
but level <code class="hljs">3</code> does more vectorization and inlining than level <code class="hljs">2</code>. In
particular, you'll see that at <code class="hljs">opt-level</code> equal to or greater than <code class="hljs">2</code> LLVM will
unroll loops. Loop unrolling has a rather high cost in terms of Flash / ROM
(e.g. from 26 bytes to 194 for a zero this array loop) but can also halve the
execution time given the right conditions (e.g. number of iterations is big
enough).</p>
<p>Currently there's no way to disable loop unrolling in <code class="hljs">opt-level = 2</code> and <code class="hljs">3</code> so
if you can't afford its cost you should optimize your program for size.</p>
<h2><a class="header" href="https://rust-embedded.github.io/book/print.html#optimize-for-size" id="optimize-for-size">Optimize for size</a></h2>
<p>As of 2018-09-18 <code class="hljs">rustc</code> supports two "optimize for size" levels: <code class="hljs">opt-level = "s"</code> and <code class="hljs">"z"</code>. These names were inherited from clang / LLVM and are not too
descriptive but <code class="hljs">"z"</code> is meant to give the idea that it produces smaller
binaries than <code class="hljs">"s"</code>.</p>
<p>If you want your release binaries to be optimized for size then change the
<code class="hljs">profile.release.opt-level</code> setting in <code class="hljs">Cargo.toml</code> as shown below.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-section">[profile.release]</span>
<span class="hljs-comment"># or "z"</span>
<span class="hljs-attr">opt-level</span> = <span class="hljs-string">"s"</span>
</code></pre>
<p>These two optimization levels greatly reduce LLVM's inline threshold, a metric
used to decide whether to inline a function or not. One of Rust principles are
zero cost abstractions; these abstractions tend to use a lot of newtypes and
small functions to hold invariants (e.g. functions that borrow an inner value
like <code class="hljs">deref</code>, <code class="hljs">as_ref</code>) so a low inline threshold can make LLVM miss
optimization opportunities (e.g. eliminate dead branches, inline calls to
closures).</p>
<p>When optimizing for size you may want to try increasing the inline threshold to
see if that has any effect on the binary size. The recommended way to change the
inline threshold is to append the <code class="hljs">-C inline-threshold</code> flag to the other
rustflags in <code class="hljs">.cargo/config</code>.</p>
<pre><div class="buttons"><button class="fa fa-copy clip-button" title="Copy to clipboard" aria-label="Copy to clipboard"><i class="tooltiptext"></i></button></div><code class="language-toml hljs ini"><span class="hljs-comment"># .cargo/config</span>
<span class="hljs-comment"># this assumes that you are using the cortex-m-quickstart template</span>
<span class="hljs-section">[target.'cfg(all(target_arch = "arm", target_os = "none"))']</span>
<span class="hljs-attr">rustflags</span> = [
  <span class="hljs-comment"># ..</span>
  "-C", "inline-threshold=123", <span class="hljs-comment"># +</span>
]
</code></pre>
<p>What value to use? <a href="https://github.com/rust-lang/rust/blob/1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122">As of 1.29.0 these are the inline thresholds that the
different optimization levels use</a>:</p>
<ul>
<li><code class="hljs">opt-level = 3</code> uses 275</li>
<li><code class="hljs">opt-level = 2</code> uses 225</li>
<li><code class="hljs">opt-level = "s"</code> uses 75</li>
<li><code class="hljs">opt-level = "z"</code> uses 25</li>
</ul>
<p>You should try <code class="hljs">225</code> and <code class="hljs">275</code> when optimizing for size.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="./The Embedded Rust Book_files/elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="./The Embedded Rust Book_files/mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="./The Embedded Rust Book_files/searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="./The Embedded Rust Book_files/clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="./The Embedded Rust Book_files/highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="./The Embedded Rust Book_files/book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    

</body></html>